<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ShootWaste Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(45deg, #0f0f23, #1a1a3e);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            touch-action: none;
        }
        
        #gameContainer {
            position: relative;
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px #00ffff;
            width: 100vw;
            height: 100vh;
            max-width: 800px;
            max-height: 600px;
            aspect-ratio: 4 / 3; /* Maintain proper aspect ratio */
        }
        
        #gameCanvas {
            background: transparent;
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            image-rendering: crisp-edges; /* Prevent blurring */
        }
        
        #saturnCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            background: #000011;
            image-rendering: crisp-edges; /* Prevent blurring */
        }
        
        @media (max-width: 1920px) {
            #gameContainer {
                border: none;
                box-shadow: none;
                max-width: none;
                max-height: none;
                aspect-ratio: 4 / 3; /* Maintain 4:3 aspect ratio */
            }
        }
        
        @media (max-width: 768px) {
            #gameContainer {
                height: 82.5vh; /* 75vh * 1.1 = 82.5vh (10% increase from the 1/4 reduced height) */
                width: 110%; /* Increase width by 10% */
                margin-left: -5%; /* Center the wider container */
            }
        }
        
        #mobileControls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            flex-direction: row;
            align-items: flex-end;
            gap: 30px;
            z-index: 10;
            width: 100%;
            max-width: 400px;
            justify-content: space-between;
        }
        
        #dpad {
            display: grid;
            grid-template-columns: 55px 55px 55px;
            grid-template-rows: 55px 55px 55px;
            gap: 8px;
        }
        
        #actionButtons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        
        .control-btn {
            background: rgba(0, 255, 255, 0.3);
            border: 2px solid #00ffff;
            border-radius: 10px;
            color: #00ffff;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            touch-action: manipulation;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        
        .control-btn:active {
            background: rgba(0, 255, 255, 0.6);
            transform: scale(0.95);
        }
        
        #shootBtn {
            width: 75px;
            height: 75px;
            border-radius: 50%;
            background: rgba(255, 255, 0, 0.3);
            border: 3px solid #ffff00;
            font-size: 22px;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.5);
        }
        
        #shootBtn:active {
            background: rgba(255, 255, 0, 0.6);
        }
        
        #weaponToggleBtn {
            width: 60px;
            height: 60px;
            border-radius: 10px;
            background: rgba(0, 255, 0, 0.3);
            border: 3px solid #00ff00;
            font-size: 12px;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
            text-align: center;
        }
        
        #weaponToggleBtn:active {
            background: rgba(0, 255, 0, 0.6);
        }
        
        @media (max-width: 768px) {
            #mobileControls {
                display: flex;
            }
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ffff;
            font-size: 18px;
            text-shadow: 0 0 10px #00ffff;
            z-index: 10;
        }
        
        #weaponDisplay {
            position: absolute;
            top: 80px;
            left: 10px;
            color: #ffff00;
            font-size: 16px;
            text-shadow: 0 0 10px #ffff00;
            z-index: 10;
        }
        
        #powerUps {
            position: absolute;
            top: 10px;
            right: 120px;
            color: #00ff00;
            font-size: 16px;
            text-shadow: 0 0 10px #00ff00;
            z-index: 10;
        }
        
        #exitBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 20px;
            background: rgba(255, 0, 0, 0.7);
            border: 2px solid #ff0000;
            color: #fff;
            cursor: pointer;
            font-size: 16px;
            border-radius: 5px;
            z-index: 1000;
        }
        
        #exitBtn:hover {
            background: rgba(255, 0, 0, 0.9);
        }
        
        .menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 50, 0.95);
            padding: 40px;
            border: 3px solid #00ffff;
            border-radius: 15px;
            text-align: center;
            color: #00ffff;
            z-index: 1000;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }
        
        #wasteTypeGrid::-webkit-scrollbar {
            width: 8px;
        }
        
        #wasteTypeGrid::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        #wasteTypeGrid::-webkit-scrollbar-thumb {
            background: #00ffff;
            border-radius: 4px;
        }
        
        #wasteTypeGrid::-webkit-scrollbar-thumb:hover {
            background: #00cccc;
            border-radius: 10px;
            text-align: center;
            color: #00ffff;
            box-shadow: 0 0 30px #00ffff;
            z-index: 100;
        }
        
        .menu h1 {
            font-size: 36px;
            margin: 0 0 20px 0;
            text-shadow: 0 0 20px #00ffff;
        }
        
        .menu button {
            margin: 10px;
            padding: 15px 30px;
            font-size: 18px;
            background: linear-gradient(45deg, #00ffff, #0088ff);
            border: none;
            border-radius: 5px;
            color: #000;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }
        
        .menu button:hover {
            background: linear-gradient(45deg, #00ffff, #00ccff);
            transform: scale(1.05);
        }
        
        #targetInfo {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(255, 255, 0, 0.9);
            border: 2px solid #ffff00;
            border-radius: 10px;
            color: #000;
            font-size: 20px;
            font-weight: bold;
            text-shadow: none;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.8);
            z-index: 10;
        }
        
        #sessionTimer {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            padding: 5px 15px;
            background: rgba(255, 100, 100, 0.8);
            border: 2px solid #ff0000;
            border-radius: 5px;
            color: #fff;
            font-size: 18px;
            font-weight: bold;
            z-index: 10;
        }
        
        #weaponHeat {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            border-radius: 10px;
            overflow: hidden;
            z-index: 10;
        }
        
        #heatBar {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #00ff00, #ffff00, #ff0000);
            transition: width 0.1s;
        }
        
        #bossLabel, #bossHealthBar {
            display: none;
        }
        
        #bossLabel {
            position: absolute;
            top: 160px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0000;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #ff0000;
        }
        
        #bossHealthBar {
            position: absolute;
            top: 190px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff0000;
            border-radius: 5px;
        }
        
        #bossHealth {
            height: 100%;
            width: 100%;
            background: linear-gradient(to right, #ff0000, #ff6600);
            border-radius: 3px;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="saturnCanvas"></canvas>
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
            <div>Accuracy: <span id="accuracy">0%</span></div>
        </div>
        
        <div id="weaponDisplay">
            Weapon: <span id="currentWeapon">Missile</span><br>
            <small>Controls: Arrow keys=Move, A/D=Rotate, Space/Click=Shoot (Mobile: D-pad=Move, Shoot button=Shoot, Toggle button=Switch Weapon)</small>
        </div>
        
        <div id="powerUps"></div>
        
        <div id="targetInfo"></div>
        <div id="sessionTimer"></div>
        
        <div id="weaponHeat">
            <div id="heatBar"></div>
        </div>
        
        <div id="bossLabel">FINAL BOSS!</div>
        <div id="bossHealthBar">
            <div id="bossHealth"></div>
        </div>
        
        <button id="exitBtn">Exit</button>
        <button id="pauseBtn" style="position: absolute; top: 10px; left: 120px; padding: 10px 20px; background: rgba(255, 255, 0, 0.7); border: 2px solid #ffff00; color: #000; cursor: pointer; font-size: 16px; border-radius: 5px; z-index: 1000;">Pause</button>
        
        <div id="languageSelect" class="menu">
            <h1>ShootWaste</h1>
            <p>Select Language / Selecteer taal / 选择语言</p>
            <button onclick="selectLanguage('en')">English</button>
            <button onclick="selectLanguage('nl')">Nederlands</button>
            <button onclick="selectLanguage('zh')">中文</button>
        </div>
        
        <div id="gameModeSelect" class="menu" style="display:none;">
            <h1>ShootWaste</h1>
            <h3>Choose Game Mode</h3>
            <button onclick="showMultiplayerLobby()" style="background: linear-gradient(45deg, #ff6600, #ff9900); margin-bottom: 10px; padding: 15px 30px; font-size: 18px;">🎮 Multiplayer</button>
            <br>
            <button onclick="startSinglePlayer()" style="background: linear-gradient(45deg, #00ff00, #00cc00); padding: 15px 30px; font-size: 18px;">👤 Single Player</button>
            <br><br>
            <button onclick="showLanguageSelect()" style="background: #666; padding: 10px 20px;">← Back to Language</button>
        </div>
        
        <div id="wasteTypePreview" class="menu" style="display:none;">
            <h2 id="previewTitle">Waste Types Guide</h2>
            <p id="previewSubtitle" style="font-size: 14px; margin-bottom: 20px;">Learn the waste categories before you start!</p>
            <div id="wasteTypeGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; max-height: 400px; overflow-y: auto; padding: 10px;">
                <!-- Waste types will be dynamically inserted here -->
            </div>
            <div style="margin-top: 20px;">
                <button id="startGameBtn" onclick="startGameFromPreview()" style="background: #00ff00; color: #000; font-weight: bold; padding: 12px 30px; font-size: 18px; margin-right: 10px; border: none; border-radius: 5px; cursor: pointer;">Start Game</button>
                <button id="skipBtn" onclick="startGameFromPreview()" style="background: #ffaa00; color: #000; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer;">Skip</button>
            </div>
        </div>
        
        <div id="gameOver" class="menu" style="display:none;">
            <h1 id="gameOverTitle">Game Over</h1>
            <p id="finalScore"></p>
            <button onclick="location.reload()" id="gameOverRestartBtn">Play Again</button>
            <button onclick="location.reload()" id="gameOverChangeBtn">Change Language</button>
        </div>
        
        <div id="victory" class="menu" style="display:none;">
            <h1 id="victoryTitle">Victory!</h1>
            <p id="victoryScore"></p>
            <button onclick="location.reload()" id="victoryRestartBtn">Play Again</button>
            <button onclick="location.reload()" id="victoryChangeBtn">Change Language</button>
        </div>
        
        <div id="nicknamePrompt" class="menu" style="display:none; z-index: 1100;">
            <h2>Enter Your Nickname</h2>
            <input type="text" id="nicknameInput" maxlength="15" placeholder="Your Name" style="padding: 10px; font-size: 18px; margin: 10px 0; width: 80%;">
            <br>
            <button id="submitNicknameBtn" style="margin-top: 10px;">Submit</button>
        </div>
        
        <div id="leaderboard" class="menu" style="display:none; z-index: 1100;">
            <h2>Leaderboard</h2>
            <div id="leaderboardTable" style="margin: 20px 0; max-height: 400px; overflow-y: auto;"></div>
            <div id="playerEntry" style="margin: 10px 0; color: #ffff00; font-weight: bold;"></div>
            <button onclick="closeLeaderboard()">Continue</button>
        </div>
        
        <div id="pauseMenu" class="menu" style="display:none;">
            <h1 id="pauseTitle">Paused</h1>
            <button onclick="togglePause()">Resume</button>
            <button onclick="location.reload()">Restart</button>
            <button onclick="location.reload()">Change Language</button>
        </div>

        <!-- Multiplayer Lobby System -->
        <div id="multiplayerLobby" class="menu" style="display:none;">
            <h2>Multiplayer Lobby</h2>
            
            <div id="playerNicknameSection" style="margin-bottom: 20px;">
                <label for="playerNickname">Your Nickname:</label>
                <input type="text" id="playerNickname" placeholder="Enter your nickname" maxlength="20" style="margin-left: 10px; padding: 5px;">
            </div>
            
            <div id="gameCreation" class="lobby-section" style="margin-bottom: 30px; padding: 20px; border: 1px solid #00ffff; border-radius: 10px;">
                <h3>Create Game</h3>
                <div class="game-options" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 15px 0;">
                    <div>
                        <label for="gameMode">Game Mode:</label>
                        <select id="gameMode" style="width: 100%; padding: 5px;">
                            <option value="cooperative">Cooperative</option>
                            <option value="competitive">Competitive</option>
                        </select>
                    </div>
                    
                    <div>
                        <label for="maxPlayers">Max Players:</label>
                        <input type="number" id="maxPlayers" min="2" max="4" value="4" style="width: 100%; padding: 5px;">
                    </div>
                    
                    <div>
                        <label for="gameDifficulty">Difficulty:</label>
                        <select id="gameDifficulty" style="width: 100%; padding: 5px;">
                            <option value="easy">Easy</option>
                            <option value="normal" selected>Normal</option>
                            <option value="hard">Hard</option>
                        </select>
                    </div>
                </div>
                <button onclick="createMultiplayerGame()" class="lobby-btn" style="width: 100%; padding: 10px; margin-top: 10px;">Create Game</button>
            </div>
            
            <div id="gameList" class="lobby-section" style="margin-bottom: 30px; padding: 20px; border: 1px solid #00ffff; border-radius: 10px;">
                <h3>Join Game</h3>
                <div id="availableGames" class="games-list" style="min-height: 100px; margin: 15px 0;">
                    <div class="loading">Looking for games...</div>
                </div>
                <button onclick="refreshGameList()" class="lobby-btn" style="width: 100%; padding: 10px;">Refresh</button>
            </div>
            
            <div id="currentLobby" class="lobby-section" style="display:none; padding: 20px; border: 1px solid #00ff00; border-radius: 10px;">
                <h3>Current Lobby</h3>
                <div id="lobbyInfo" style="margin: 15px 0;">
                    <div id="lobbyGameMode"></div>
                    <div id="lobbyDifficulty"></div>
                </div>
                <div id="lobbyPlayers" class="players-list" style="margin: 15px 0; min-height: 50px;"></div>
                <div id="lobbyControls" style="margin-top: 20px;">
                    <button id="multiplayerStartBtn" onclick="startMultiplayerGame()" class="lobby-btn" style="display:none; padding: 10px 20px; margin-right: 10px; background: #00ff00; color: #000;">Start Game</button>
                    <button onclick="leaveLobby()" class="lobby-btn" style="padding: 10px 20px; background: #ff0000; color: #fff;">Leave Lobby</button>
                </div>
                <div id="lobbyStatus" style="margin-top: 15px; font-style: italic;"></div>
            </div>
            
            <button onclick="showMainMenu()" class="lobby-btn" style="width: 100%; padding: 15px; margin-top: 20px; background: #666; color: #fff;">Back to Main Menu</button>
        </div>

        <!-- Multiplayer Game UI -->
        <div id="multiplayerGameUI" style="display:none; position: absolute; top: 10px; left: 10px; z-index: 1000; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px;">
            <div id="multiplayerPlayers" class="multiplayer-info" style="margin-bottom: 10px;">
                <h4 style="margin: 0 0 5px 0; color: #00ffff;">Players:</h4>
                <div id="playersList"></div>
            </div>
            <div id="multiplayerScore" class="multiplayer-info" style="margin-bottom: 10px;">
                <h4 style="margin: 0 0 5px 0; color: #ffff00;">Team Score: <span id="teamScore">0</span></h4>
            </div>
            <div id="connectionStatus" class="multiplayer-info">
                <span id="connectionIndicator" style="color: #00ff00;">🟢 Connected</span>
            </div>
        </div>
        
        <div id="mobileControls">
            <div id="dpad">
                <div></div>
                <div class="control-btn" data-dir="up">▲</div>
                <div></div>
                <div class="control-btn" data-dir="left">◄</div>
                <div></div>
                <div class="control-btn" data-dir="right">►</div>
                <div></div>
                <div class="control-btn" data-dir="down">▼</div>
                <div></div>
            </div>
            <div id="actionButtons">
                <button id="weaponToggleBtn" class="control-btn">Missile</button>
                <button id="shootBtn" class="control-btn">🔥</button>
            </div>
        </div>
    </div>
    
    <!-- Firebase SDK -->
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.1.0/firebase-app.js';
        import { getDatabase, ref, push, set, query, orderByChild, limitToLast, get, onValue, update, remove, equalTo, off } from 'https://www.gstatic.com/firebasejs/11.1.0/firebase-database.js';
        import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/11.1.0/firebase-auth.js';

        // Firebase configuration
        // IMPORTANT: Replace with your actual Firebase project credentials
        const firebaseConfig = {
            apiKey: "AIzaSyBeOfeGzsT9NzLqbFRajz_dbhJlEqRk82A",
            authDomain: "game20250601.firebaseapp.com",
            databaseURL: "https://game20250601-default-rtdb.firebaseio.com",
            projectId: "game20250601",
            storageBucket: "game20250601.firebasestorage.app",
            messagingSenderId: "553578269459",
            appId: "1:553578269459:web:75017156f8b91d9bc3e8e6"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        const auth = getAuth(app);

        // Sign in anonymously
        let isAuthenticated = false;
        
        const signInUser = async () => {
            try {
                await signInAnonymously(auth);
                console.log('Successfully signed in anonymously');
                isAuthenticated = true;
                window.firebaseAuthenticated = true;
            } catch (error) {
                console.error('Error signing in anonymously:', error);
                isAuthenticated = false;
                window.firebaseAuthenticated = false;
            }
        };

        // Listen for authentication state changes
        onAuthStateChanged(auth, (user) => {
            if (user) {
                console.log('User authenticated:', user.uid);
                isAuthenticated = true;
                window.firebaseAuthenticated = true;
            } else {
                console.log('User not authenticated');
                isAuthenticated = false;
                window.firebaseAuthenticated = false;
                // Try to sign in anonymously
                signInUser();
            }
        });

        // Initial sign in attempt
        signInUser();

        // Make Firebase database and functions available globally
        window.firebaseDatabase = database;
        window.firebaseRef = ref;
        window.firebaseGet = get;
        window.firebaseQuery = query;
        window.firebaseOrderByChild = orderByChild;
        window.firebaseEqualTo = equalTo;
        window.firebaseUpdate = update;
        window.firebaseSet = set;
        window.firebasePush = push;
        window.firebaseRemove = remove;
        window.firebaseOnValue = onValue;
        window.firebaseOff = off;
        window.firebaseLimitToLast = limitToLast;
        
        // Set Firebase initialization flag
        window.firebaseInitialized = true;
        console.log('Firebase functions made globally available successfully');

        // Make Firebase functions available globally
        window.firebaseDB = {
            addScore: async (name, score) => {
                try {
                    const scoresRef = ref(database, 'leaderboard/shooting');
                    const newScoreRef = push(scoresRef);
                    await set(newScoreRef, {
                        name: name.trim() || 'Anonymous',
                        score,
                        timestamp: Date.now(),
                        gameType: 'shooting'
                    });
                    return true;
                } catch (error) {
                    console.error('Error adding score to Firebase:', error);
                    return false;
                }
            },
            getTopScores: async (limit = 10) => {
                try {
                    const scoresRef = ref(database, 'leaderboard/shooting');
                    const topScoresQuery = query(scoresRef, orderByChild('score'), limitToLast(limit * 2));
                    const snapshot = await get(topScoresQuery);
                    
                    if (!snapshot.exists()) {
                        return [];
                    }

                    const scores = [];
                    snapshot.forEach((childSnapshot) => {
                        scores.push(childSnapshot.val());
                    });

                    return scores.sort((a, b) => b.score - a.score).slice(0, limit);
                } catch (error) {
                    console.error('Error getting scores from Firebase:', error);
                    return [];
                }
            }
        };

        // Multiplayer Manager
        window.multiplayerManager = {
            gameId: null,
            playerId: null,
            playerNickname: '',
            isHost: false,
            isMultiplayer: false,
            players: new Map(),
            gameListeners: [],
            
            // Generate unique player ID
            generatePlayerId() {
                return 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            },
            
            // Create a new multiplayer game
            async createGame(settings) {
                try {
                    // Wait for Firebase to be initialized and authenticated
                    if (!window.firebaseInitialized || !window.firebaseDatabase || !window.firebaseAuthenticated) {
                        console.log('Waiting for Firebase initialization and authentication...');
                        await new Promise(resolve => {
                            const checkFirebase = () => {
                                if (window.firebaseInitialized && window.firebaseDatabase && window.firebaseAuthenticated) {
                                    resolve();
                                } else {
                                    setTimeout(checkFirebase, 100);
                                }
                            };
                            checkFirebase();
                        });
                    }
                    
                    console.log('Starting game creation with settings:', settings);
                    console.log('Firebase functions available:', {
                        database: typeof window.firebaseDatabase,
                        ref: typeof window.firebaseRef,
                        push: typeof window.firebasePush,
                        set: typeof window.firebaseSet
                    });
                    
                    this.playerId = this.generatePlayerId();
                    this.playerNickname = document.getElementById('playerNickname').value.trim() || 'Player';
                    this.isHost = true;
                    this.isMultiplayer = true;
                    
                    console.log('Player details:', {
                        playerId: this.playerId,
                        nickname: this.playerNickname,
                        language: currentLanguage
                    });
                    
                    console.log('Creating Firebase reference...');
                    const gamesRef = window.firebaseRef(window.firebaseDatabase, 'games');
                    console.log('Games reference created:', gamesRef);
                    
                    const gameRef = window.firebasePush(gamesRef);
                    this.gameId = gameRef.key;
                    console.log('Game reference created with ID:', this.gameId);
                    
                    const gameData = {
                        gameInfo: {
                            mode: settings.mode || 'cooperative',
                            maxPlayers: parseInt(settings.maxPlayers) || 4,
                            currentPlayers: 1,
                            status: 'waiting',
                            sessionTime: 30,
                            targetType: '',
                            createdAt: Date.now(),
                            language: window.currentLanguage,
                            difficulty: settings.difficulty || 'normal',
                            hostId: this.playerId
                        },
                        players: {
                            [this.playerId]: {
                                nickname: this.playerNickname,
                                x: 400,
                                y: 520,
                                rotation: 0,
                                lives: 5,
                                connected: true,
                                lastUpdate: Date.now(),
                                isHost: true
                            }
                        },
                        gameState: {
                            score: 0,
                            totalLives: 5,
                            enemies: {},
                            bullets: {},
                            powerUps: {},
                            boss: null
                        }
                    };
                    
                    console.log('Game data prepared:', gameData);
                    console.log('Setting game data to Firebase...');
                    
                    await window.firebaseSet(gameRef, gameData);
                    console.log('Game data set successfully');
                    
                    this.setupGameListeners();
                    this.showCurrentLobby();
                    
                    console.log('Game created successfully with ID:', this.gameId);
                    return true;
                } catch (error) {
                    console.error('Detailed error creating game:', error);
                    console.error('Error name:', error.name);
                    console.error('Error message:', error.message);
                    console.error('Error stack:', error.stack);
                    alert('Error creating game: ' + error.message);
                    return false;
                }
            },
            
            // Join an existing game
            async joinGame(gameId) {
                try {
                    this.gameId = gameId;
                    this.playerId = this.generatePlayerId();
                    this.playerNickname = document.getElementById('playerNickname').value.trim() || 'Player';
                    this.isHost = false;
                    this.isMultiplayer = true;
                    
                    // Check if game exists and has space
                    const gameRef = window.firebaseRef(window.firebaseDatabase, `games/${gameId}`);
                    const snapshot = await window.firebaseGet(gameRef);
                    
                    if (!snapshot.exists()) {
                        throw new Error('Game not found');
                    }
                    
                    const gameData = snapshot.val();
                    if (gameData.gameInfo.currentPlayers >= gameData.gameInfo.maxPlayers) {
                        throw new Error('Game is full');
                    }
                    
                    // Add player to game
                    const playerRef = window.firebaseRef(window.firebaseDatabase, `games/${gameId}/players/${this.playerId}`);
                    await window.firebaseSet(playerRef, {
                        nickname: this.playerNickname,
                        x: 400,
                        y: 520,
                        rotation: 0,
                        lives: 5,
                        connected: true,
                        lastUpdate: Date.now(),
                        isHost: false
                    });
                    
                    // Update player count
                    const currentPlayersRef = window.firebaseRef(window.firebaseDatabase, `games/${gameId}/gameInfo/currentPlayers`);
                    await window.firebaseSet(currentPlayersRef, gameData.gameInfo.currentPlayers + 1);
                    
                    this.setupGameListeners();
                    this.showCurrentLobby();
                    
                    console.log('Joined game:', gameId);
                    return true;
                } catch (error) {
                    console.error('Error joining game:', error);
                    alert('Failed to join game: ' + error.message);
                    return false;
                }
            },
            
            // Setup real-time listeners
            setupGameListeners() {
                if (!this.gameId) return;
                
                // Listen to players changes
                const playersRef = window.firebaseRef(window.firebaseDatabase, `games/${this.gameId}/players`);
                const playersUnsubscribe = window.firebaseOnValue(playersRef, (snapshot) => {
                    if (snapshot.exists()) {
                        const playersData = snapshot.val();
                        this.players.clear();
                        Object.entries(playersData).forEach(([id, playerData]) => {
                            this.players.set(id, playerData);
                        });
                        this.updateLobbyDisplay();
                        
                        // Update start button visibility after player data changes
                        if (this.isHost) {
                            const startBtn = document.getElementById('multiplayerStartBtn');
                            if (startBtn) {
                                startBtn.style.display = 'inline-block';
                            }
                        }
                    }
                });
                this.gameListeners.push(playersUnsubscribe);
                
                // Listen to game state changes
                const gameStateRef = window.firebaseRef(window.firebaseDatabase, `games/${this.gameId}/gameState`);
                const gameStateUnsubscribe = window.firebaseOnValue(gameStateRef, (snapshot) => {
                    if (snapshot.exists() && this.isMultiplayer) {
                        const gameStateData = snapshot.val();
                        this.syncLocalGameState(gameStateData);
                    }
                });
                this.gameListeners.push(gameStateUnsubscribe);
                
                // Listen to game info changes
                const gameInfoRef = window.firebaseRef(window.firebaseDatabase, `games/${this.gameId}/gameInfo`);
                const gameInfoUnsubscribe = window.firebaseOnValue(gameInfoRef, (snapshot) => {
                    if (snapshot.exists()) {
                        const gameInfo = snapshot.val();
                        this.updateLobbyInfo(gameInfo);
                        
                        if (gameInfo.status === 'active' && !gameState.gameStarted) {
                            // Hide lobby and start game for all players (not just host)
                            document.getElementById('multiplayerLobby').style.display = 'none';
                            document.getElementById('multiplayerGameUI').style.display = 'block';
                            gameState.gameStarted = true;
                            startGameFromPreview();
                        }
                    }
                });
                this.gameListeners.push(gameInfoUnsubscribe);
            },
            
            // Update player position
            async updatePlayerPosition(x, y, rotation) {
                if (!this.gameId || !this.playerId) return;
                
                try {
                    const playerRef = window.firebaseRef(window.firebaseDatabase, `games/${this.gameId}/players/${this.playerId}`);
                    await window.firebaseUpdate(playerRef, { 
                        x: Math.round(x), 
                        y: Math.round(y), 
                        rotation: rotation, 
                        lastUpdate: Date.now() 
                    });
                } catch (error) {
                    console.error('Error updating player position:', error);
                }
            },
            
            // Sync bullets fired
            async fireBullet(bulletData) {
                if (!this.gameId || !this.playerId) return;
                
                try {
                    const bulletRef = window.firebasePush(window.firebaseRef(window.firebaseDatabase, `games/${this.gameId}/gameState/bullets`));
                    await window.firebaseSet(bulletRef, { 
                        ...bulletData, 
                        playerId: this.playerId,
                        timestamp: Date.now()
                    });
                } catch (error) {
                    console.error('Error firing bullet:', error);
                }
            },
            
            // Sync local game state with server
            syncLocalGameState(gameStateData) {
                if (!gameStateData) return;
                
                // Update team score
                if (gameStateData.score !== undefined) {
                    gameState.score = gameStateData.score;
                    document.getElementById('score').textContent = gameState.score;
                    const teamScoreEl = document.getElementById('teamScore');
                    if (teamScoreEl) teamScoreEl.textContent = gameState.score;
                }
                
                // Sync team lives
                if (gameStateData.totalLives !== undefined) {
                    gameState.lives = gameStateData.totalLives;
                    document.getElementById('lives').textContent = gameState.lives;
                }
                
                // Sync enemies (shared enemy state)
                if (gameStateData.enemies && typeof enemies !== 'undefined') {
                    // Clear local enemies and sync with server
                    enemies.length = 0;
                    Object.entries(gameStateData.enemies).forEach(([enemyId, enemyData]) => {
                        if (enemyData && enemyData.active !== false) {
                            enemies.push({
                                ...enemyData,
                                multiplayerId: enemyId
                            });
                        }
                    });
                }
                
                // Sync bullets (other players' bullets)
                if (gameStateData.bullets && typeof player !== 'undefined' && player.bullets) {
                    Object.entries(gameStateData.bullets).forEach(([bulletId, bulletData]) => {
                        if (bulletData.playerId !== this.playerId && bulletData.active !== false) {
                            // Add other players' bullets to local game
                            const existingBullet = player.bullets.find(b => b.multiplayerId === bulletId);
                            if (!existingBullet) {
                                player.bullets.push({
                                    ...bulletData,
                                    multiplayerId: bulletId,
                                    isRemote: true
                                });
                            }
                        }
                    });
                }
                
                // Sync power-ups
                if (gameStateData.powerUps && typeof powerUps !== 'undefined') {
                    powerUps.length = 0;
                    Object.entries(gameStateData.powerUps).forEach(([powerUpId, powerUpData]) => {
                        if (powerUpData && powerUpData.active !== false) {
                            powerUps.push({
                                ...powerUpData,
                                multiplayerId: powerUpId
                            });
                        }
                    });
                }
            },
            
            // Leave current game
            async leaveGame() {
                if (!this.gameId || !this.playerId) return;
                
                try {
                    // Remove player from game
                    const playerRef = window.firebaseRef(window.firebaseDatabase, `games/${this.gameId}/players/${this.playerId}`);
                    await window.firebaseRemove(playerRef);
                    
                    // Update player count
                    const gameRef = window.firebaseRef(window.firebaseDatabase, `games/${this.gameId}`);
                    const snapshot = await window.firebaseGet(gameRef);
                    if (snapshot.exists()) {
                        const gameData = snapshot.val();
                        const newPlayerCount = Math.max(0, gameData.gameInfo.currentPlayers - 1);
                        await window.firebaseUpdate(window.firebaseRef(window.firebaseDatabase, `games/${this.gameId}/gameInfo`), {
                            currentPlayers: newPlayerCount
                        });
                        
                        // If no players left, delete the game
                        if (newPlayerCount === 0) {
                            await window.firebaseRemove(gameRef);
                        }
                    }
                    
                    // Clean up listeners safely
                    this.gameListeners.forEach(listener => {
                        try {
                            if (listener && typeof listener === 'function') {
                                listener(); // Call the unsubscribe function
                            }
                        } catch (error) {
                            console.error('Error cleaning up listener:', error);
                        }
                    });
                    this.gameListeners = [];
                    
                    // Reset state
                    this.gameId = null;
                    this.playerId = null;
                    this.isHost = false;
                    this.isMultiplayer = false;
                    this.players.clear();
                    
                    console.log('Left game successfully');
                } catch (error) {
                    console.error('Error leaving game:', error);
                }
            },
            
            // Show current lobby
            showCurrentLobby() {
                document.getElementById('gameCreation').style.display = 'none';
                document.getElementById('gameList').style.display = 'none';
                document.getElementById('currentLobby').style.display = 'block';
                
                if (this.isHost) {
                    document.getElementById('multiplayerStartBtn').style.display = 'inline-block';
                }
            },
            
            // Update lobby display
            updateLobbyDisplay() {
                const playersDiv = document.getElementById('lobbyPlayers');
                let html = '<h4>Players in Lobby:</h4>';
                
                this.players.forEach((playerData, playerId) => {
                    const isCurrentPlayer = playerId === this.playerId;
                    const hostBadge = playerData.isHost ? ' 👑' : '';
                    const connectionStatus = playerData.connected ? '🟢' : '🔴';
                    
                    html += `<div style="margin: 5px 0; padding: 8px; background: ${isCurrentPlayer ? 'rgba(0,255,255,0.2)' : 'rgba(255,255,255,0.1)'}; border-radius: 5px;">
                        ${connectionStatus} ${playerData.nickname}${hostBadge}
                        ${isCurrentPlayer ? ' (You)' : ''}
                    </div>`;
                });
                
                playersDiv.innerHTML = html;
            },
            
            // Update lobby info
            updateLobbyInfo(gameInfo) {
                document.getElementById('lobbyGameMode').textContent = `Mode: ${gameInfo.mode}`;
                document.getElementById('lobbyDifficulty').textContent = `Difficulty: ${gameInfo.difficulty}`;
                
                const statusDiv = document.getElementById('lobbyStatus');
                statusDiv.textContent = `Players: ${gameInfo.currentPlayers}/${gameInfo.maxPlayers} | Status: ${gameInfo.status}`;
            },
            
            // Start multiplayer gameplay
            async startMultiplayerGameplay() {
                if (!this.isHost) return;
                
                try {
                    await window.firebaseUpdate(window.firebaseRef(window.firebaseDatabase, `games/${this.gameId}/gameInfo`), {
                        status: 'active'
                    });
                    
                    // Hide lobby and start game
                    document.getElementById('multiplayerLobby').style.display = 'none';
                    document.getElementById('multiplayerGameUI').style.display = 'block';
                    
                    // Start the game
                    gameState.gameStarted = true;
                    startGameFromPreview();
                } catch (error) {
                    console.error('Error starting multiplayer game:', error);
                }
            }
        };
    </script>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const saturnCanvas = document.getElementById('saturnCanvas');
        const saturnCtx = saturnCanvas.getContext('2d');
        
        canvas.width = 800;
        canvas.height = 600;
        saturnCanvas.width = 800;
        saturnCanvas.height = 600;
        
        // Game translations
        const translations = {
            en: {
                gameOver: 'Game Over',
                victory: 'Victory!',
                paused: 'Paused',
                finalScore: 'Final Score:',
                playAgain: 'Play Again',
                changeLanguage: 'Change Language',
                resume: 'Resume',
                restart: 'Restart',
                targetWaste: 'Target:',
                sessionTime: 'Time:',
                bossWarning: 'FINAL BOSS!',
                comboDouble: 'Double Kill!',
                comboTriple: 'Triple Kill!',
                comboQuad: 'Quad Kill!',
                comboMega: 'MEGA KILL!',
                powerUpMissile: 'Missile Speed↑',
                powerUpLaser: 'Laser Power↑',
                powerUpCooling: 'Fast Cooling',
                overheated: 'OVERHEATED!',
                previewTitle: 'Waste Types Guide',
                previewSubtitle: 'Learn the waste categories before you start!',
                startGame: 'Start Game',
                skip: 'Skip'
            },
            nl: {
                gameOver: 'Game Over',
                victory: 'Overwinning!',
                paused: 'Gepauzeerd',
                finalScore: 'Eindresultaat:',
                playAgain: 'Opnieuw spelen',
                changeLanguage: 'Taal wijzigen',
                resume: 'Hervatten',
                restart: 'Herstarten',
                targetWaste: 'Doel:',
                sessionTime: 'Tijd:',
                bossWarning: 'FINAL BOSS!',
                comboDouble: 'Dubbele Kill!',
                comboTriple: 'Driedubbele Kill!',
                comboQuad: 'Viervoudige Kill!',
                comboMega: 'MEGA KILL!',
                powerUpMissile: 'Raketsnelheid↑',
                powerUpLaser: 'Laserkracht↑',
                powerUpCooling: 'Snelle Koeling',
                overheated: 'OVERVERHIT!',
                previewTitle: 'Afvaltypen Gids',
                previewSubtitle: 'Leer de afvalcategorieën voordat je begint!',
                startGame: 'Start Spel',
                skip: 'Overslaan'
            },
            zh: {
                gameOver: '游戏结束',
                victory: '胜利！',
                paused: '已暂停',
                finalScore: '最终得分：',
                playAgain: '再玩一次',
                changeLanguage: '更改语言',
                resume: '继续',
                restart: '重新开始',
                targetWaste: '目标：',
                sessionTime: '时间：',
                bossWarning: '最终Boss！',
                comboDouble: '双杀！',
                comboTriple: '三杀！',
                comboQuad: '四杀！',
                comboMega: '超级连杀！',
                powerUpMissile: '导弹速度↑',
                powerUpLaser: '激光威力↑',
                powerUpCooling: '快速冷却',
                overheated: '过热！',
                previewTitle: '垃圾类型指南',
                previewSubtitle: '开始前了解垃圾分类！',
                startGame: '开始游戏',
                skip: '跳过'
            }
        };
        
        let currentLanguage = 'en';
        // Make currentLanguage globally accessible
        window.currentLanguage = currentLanguage;
        
        function t(key) {
            return translations[currentLanguage][key] || key;
        }
        
        // Waste data from emoji_selected.md
        const wasteData = [
            { en: 'Batteries', nl: 'Batterijen', zh: '电池', type: 'grofvuil', emoji: '🔋' },
            { en: 'Computer', nl: 'Computer', zh: '电脑', type: 'e-waste', emoji: '💻' },
            { en: 'Electrical Appliance', nl: 'Elektrisch Apparaat', zh: '电器', type: 'e-waste', emoji: '🔌' },
            { en: 'Watch', nl: 'Horloge', zh: '手表', type: 'rest', emoji: '⌚' },
            { en: 'Refrigerator or Freezer', nl: 'Koel Of Vrieskast', zh: '冰箱或冰柜', type: 'grofvuil', emoji: '🗄️' },
            { en: 'Mobile Phone', nl: 'Mobiele Telefoon', zh: '手机', type: 'e-waste', emoji: '📱' },
            { en: 'Modem', nl: 'Modem', zh: '调制解调器', type: 'e-waste', emoji: '📡' },
            { en: 'Protective Agent Against Virus', nl: 'Beschermingsmiddel Tegen Virus', zh: '抗病毒产品', type: 'rest', emoji: '🦠' },
            { en: 'Big Bag', nl: 'Grote Zak', zh: '大袋子', type: 'rest', emoji: '🛍️' },
            { en: 'CD or DVD', nl: 'Cd Of Dvd', zh: '光盘或DVD', type: 'rest', emoji: '💿' },
            { en: 'Cassette Tape or Video Tape', nl: 'Cassetteband Of Videoband', zh: '盒式磁带或录像带', type: 'rest', emoji: '📼' },
            { en: 'Diskette', nl: 'Diskette', zh: '软盘', type: 'e-waste', emoji: '💾' },
            { en: 'Photo And Film Material', nl: 'Foto En Filmmateriaal', zh: '照片和胶片材料', type: 'rest', emoji: '🎞️' },
            { en: 'Hypodermic Needle', nl: 'Injectienaald', zh: '注射针头', type: 'kca', emoji: '💉' },
            { en: 'Magnet', nl: 'Magneet', zh: '磁铁', type: 'rest', emoji: '🧲' },
            { en: 'Radioactive Products', nl: 'Radioactieve Producten', zh: '放射性产品', type: 'kca', emoji: '☢️' },
            { en: 'Incandescent Or Halogen Bulb', nl: 'Gloeilamp Of Halogeenlamp', zh: '白炽灯或卤素灯', type: 'rest', emoji: '💡' },
            { en: 'Wallpaper Wall Covering', nl: 'Behang Wandbekleding', zh: '墙纸', type: 'grofvuil', emoji: '🖼️' },
            { en: 'Furniture', nl: 'Meubel', zh: '家具', type: 'grofvuil', emoji: '🪑' },
            { en: 'Mattress', nl: 'Matras', zh: '床垫', type: 'grofvuil', emoji: '🛏️' },
            { en: 'Pan', nl: 'Pan', zh: '锅', type: 'grofvuil', emoji: '🍳' },
            { en: 'Carpet', nl: 'Tapijt', zh: '地毯', type: 'grofvuil', emoji: '🏽' },
            { en: 'Tent Cotton Or Plastic', nl: 'Tent Van Katoen Of Plastic', zh: '棉或塑料帐篷', type: 'grofvuil', emoji: '🎪' },
            { en: 'Prosthesis', nl: 'Prothese', zh: '假体', type: 'rest', emoji: '🦾' },
            { en: 'Construction waste', nl: 'Bouwafval', zh: '建筑垃圾', type: 'grofvuil', emoji: '🧱' },
            { en: 'Floral foam', nl: 'Steekschuim', zh: '花泥', type: 'rest', emoji: '💐' },
            { en: 'Impregnated Wood', nl: 'Geimpregneerd Hout', zh: '防腐木', type: 'grofvuil', emoji: '🌲' },
            { en: 'Plastic Frame', nl: 'Kunststof Lijstje', zh: '塑料相框', type: 'rest', emoji: '🖼️' },
            { en: 'Stationery', nl: 'Kantoorartikelen', zh: '文具', type: 'rest', emoji: '✏️' },
            { en: 'Glass Vase', nl: 'Glazen Vaas', zh: '玻璃花瓶', type: 'glas', emoji: '🏺' },
            { en: 'Glass Bottle Or Jar', nl: 'Glazen Fles Of Pot', zh: '玻璃瓶或罐', type: 'glas', emoji: '🍾' },
            { en: 'Special Paper', nl: 'Speciaal Papier', zh: '特殊纸张', type: 'papier', emoji: '📜' },
            { en: 'Binder', nl: 'Ordner', zh: '文件夹', type: 'rest', emoji: '📁' },
            { en: 'Paper And Cardboard', nl: 'Papier En Karton', zh: '纸和纸板', type: 'papier', emoji: '📦' },
            { en: 'Drink Carton', nl: 'Drinkpak', zh: '饮料盒', type: 'pmd', emoji: '🧃' },
            { en: 'Cardboard Cup', nl: 'Kartonnen Beker', zh: '纸杯', type: 'rest', emoji: '🥤' },
            { en: 'Chemical Waste', nl: 'Chemisch Afval', zh: '化学废物', type: 'kca', emoji: '🧪' },
            { en: 'Paint And Accessories', nl: 'Verf En Toebehoren', zh: '油漆和配件', type: 'kca', emoji: '🎨' },
            { en: 'Fuel And Oil', nl: 'Brandstof En Olie', zh: '燃料和油', type: 'kca', emoji: '🛢️' },
            { en: 'Medicine', nl: 'Medicijn', zh: '药品', type: 'kca', emoji: '💊' },
            { en: 'Nail Polish', nl: 'Nagellak', zh: '指甲油', type: 'rest', emoji: '💅' },
            { en: 'Empty Plastic Packaging of Small Chemical Waste', nl: 'Lege Kunststof Verpakking Van Klein Chemisch Afval', zh: '小化学废物的空塑料包装', type: 'pmd', emoji: '🛢️' },
            { en: 'Empty Aerosol Can', nl: 'Lege Spuitbus', zh: '空喷雾罐', type: 'pmd', emoji: '🧴' },
            { en: 'Metal Can', nl: 'Metalen Blik', zh: '金属罐', type: 'pmd', emoji: '🥫' },
            { en: 'Drink Can', nl: 'Drinkblik', zh: '饮料罐', type: 'pmd', emoji: '🥤' },
            { en: 'Crown Cap', nl: 'Kroonkurk', zh: '王冠盖', type: 'pmd', emoji: '👑' },
            { en: 'Pouch', nl: 'Gripzakje', zh: '小袋', type: 'rest', emoji: '💼' },
            { en: 'Clothing', nl: 'Kleding', zh: '衣物', type: 'textiel', emoji: '👕' },
            { en: 'Shoes', nl: 'Schoenen', zh: '鞋子', type: 'textiel', emoji: '👟' },
            { en: 'Textile', nl: 'Textiel', zh: '纺织品', type: 'textiel', emoji: '🧵' },
            { en: 'Plastic Bag Trash Bag Or Foil', nl: 'Plastic Zak Vuilniszak Of Folie', zh: '塑料袋垃圾袋或薄膜', type: 'pmd', emoji: '🛍️' },
            { en: 'Plastic Tray', nl: 'Plastic Schaaltje', zh: '塑料托盘', type: 'pmd', emoji: '🍽️' },
            { en: 'Plastic Bowl Or Tub', nl: 'Plastic Bak Of Kuip', zh: '塑料碗或盆', type: 'pmd', emoji: '🥣' },
            { en: 'Plastic Card Or Card', nl: 'Plastic Pasje Of Kaartje', zh: '塑料卡或卡片', type: 'rest', emoji: '💳' },
            { en: 'Non-Recyclable Utensil', nl: 'Bestek Niet Recyclebaar', zh: '不可回收餐具', type: 'rest', emoji: '🍴' },
            { en: 'Animal Poop', nl: 'Dierenpoep', zh: '动物粪便', type: 'rest', emoji: '💩' },
            { en: 'Sharp Object', nl: 'Scherp Voorwerp', zh: '锋利物品', type: 'rest', emoji: '🔪' },
            { en: 'Crockery And Earthenware', nl: 'Serviesgoed En Aardewerk', zh: '陶瓷和陶器', type: 'rest', emoji: '🏺' },
            { en: 'Candle Wax', nl: 'Kaarsenvet', zh: '蜡烛蜡', type: 'rest', emoji: '🕯️' },
            { en: 'Adhesive Tape', nl: 'Plakband', zh: '胶带', type: 'rest', emoji: '🩹' },
            { en: 'Cheese Paper', nl: 'Kaaspapier', zh: '奶酪纸', type: 'rest', emoji: '🧀' },
            { en: 'Coffee Cup', nl: 'Koffiebeker', zh: '咖啡杯', type: 'rest', emoji: '☕' },
            { en: 'Lit Fireworks', nl: 'Afgestoken Vuurwerk', zh: '燃放的烟花', type: 'rest', emoji: '🎉' },
            { en: 'Fruit Or Vegetable Net', nl: 'Groente Of Fruitnetje', zh: '水果或蔬菜网', type: 'rest', emoji: '🕸️' },
            { en: 'Coarse Garden Waste', nl: 'Grof Tuinafval', zh: '粗园林废物', type: 'grofvuil', emoji: '🌳' },
            { en: 'Ground', nl: 'Grond', zh: '土壤', type: 'gft', emoji: '🌱' },
            { en: 'Garden Waste And Plant Remains', nl: 'Tuinafval En Plantenresten', zh: '园林废物和植物残留', type: 'gft', emoji: '🌿' },
            { en: 'Garden tools', nl: 'Tuingereedschap', zh: '园艺工具', type: 'grofvuil', emoji: '🛠️' },
            { en: 'Meat And Fish Waste', nl: 'Vlees En Visafval', zh: '肉和鱼废料', type: 'gft', emoji: '🥩' },
            { en: 'Food remains', nl: 'Voedselresten', zh: '食物残渣', type: 'gft', emoji: '🍔' },
            { en: 'Dairy Remnant', nl: 'Zuivel Restant', zh: '乳制品残余', type: 'gft', emoji: '🍦' },
            { en: 'Bicycle', nl: 'Fiets', zh: '自行车', type: 'grofvuil', emoji: '🚲' }
        ];
        
        // Get unique waste types
        const wasteTypes = [...new Set(wasteData.map(w => w.type))];
        
        // Game state
        const gameState = {
            score: 0,
            lives: 5, // Start with 5 lives
            gameOver: false,
            victory: false,
            paused: false,
            targetType: '',
            sessionTime: 30,
            sessionTimer: null,
            comboKills: [],
            comboTimer: 0,
            weaponHeat: 0,
            overheated: false,
            cooldownTimer: 0,
            missilePowerUp: false,
            missilePowerUpTime: 0,
            laserPowerUp: false,
            laserPowerUpTime: 0,
            coolingPowerUp: false,
            coolingPowerUpTime: 0,
            lastLifeScore: 0, // Track when last bonus life was awarded
            correctKills: 0, // Track correct type kills
            totalKills: 0,    // Track all kills
            lastTime: 0
        };
        
        // Mobile scale factor for better visibility on small screens
        function getMobileScaleFactor() {
            const isMobile = window.innerWidth <= 768;
            return isMobile ? 1.4 : 1.0;
        }
        
        // Mobile speed modifier for falling waste items (0.75x speed on mobile)
        function getMobileSpeedModifier() {
            const isMobile = window.innerWidth <= 768;
            return isMobile ? 0.75 : 1.0;
        }
        
        // Player with mobile scaling
        function getPlayerSize() {
            const baseSize = 40;
            const scaleFactor = getMobileScaleFactor();
            return {
                width: Math.round(baseSize * scaleFactor),
                height: Math.round(baseSize * scaleFactor)
            };
        }
        
        const playerSize = getPlayerSize();
        const player = {
            x: canvas.width / 2 - playerSize.width / 2,
            y: canvas.height - 80,
            width: playerSize.width,
            height: playerSize.height,
            speed: 5,
            bullets: [],
            weaponType: 'missile', // 'missile' or 'laser'
            rotation: 0, // 0 is upright
            rotationSpeed: 0.05,
            rollAngle: 0, // For body roll effect
            horizontalVelocity: 0 // Track horizontal movement for roll effect
        };
        
        // Enemies
        let enemies = [];
        let boss = null;
        let bossSpawned = false;
        let bossDefeated = false;
        
        // Power-ups
        let powerUps = [];
        
        // Particles
        let particles = [];
        
        // Input
        const keys = {};
        const mousePos = { x: 0, y: 0 };
        let isShooting = false;
        let lastShootTime = 0;
        let continuousShootStart = 0;
        let animationFrameId;
        
        // Language selection
        function selectLanguage(lang) {
            currentLanguage = lang;
            window.currentLanguage = lang;
            
            // Update UI text
            updateUIText();
            
            // Show game mode selection instead of starting game immediately
            document.getElementById('languageSelect').style.display = 'none';
            document.getElementById('gameModeSelect').style.display = 'block';
        }
        
        function showLanguageSelect() {
            document.getElementById('gameModeSelect').style.display = 'none';
            document.getElementById('languageSelect').style.display = 'block';
        }
        
        function startSinglePlayer() {
            // Start single player game - show waste type preview
            document.getElementById('gameModeSelect').style.display = 'none';
            showWasteTypePreview();
        }
        
        function updateUIText() {
            // Update UI elements with current language
            document.getElementById('previewTitle').textContent = t('previewTitle');
            document.getElementById('previewSubtitle').textContent = t('previewSubtitle');
            document.getElementById('startGameBtn').textContent = t('startGame');
            document.getElementById('skipBtn').textContent = t('skip');
            document.getElementById('gameOverTitle').textContent = t('gameOver');
            document.getElementById('victoryTitle').textContent = t('victory');
            document.getElementById('pauseTitle').textContent = t('paused');
            document.getElementById('gameOverRestartBtn').textContent = t('playAgain');
            document.getElementById('gameOverChangeBtn').textContent = t('changeLanguage');
            document.getElementById('victoryRestartBtn').textContent = t('playAgain');
            document.getElementById('victoryChangeBtn').textContent = t('changeLanguage');
        }
        
        function showMainMenu() {
            // Reset to main menu
            document.getElementById('multiplayerLobby').style.display = 'none';
            document.getElementById('gameModeSelect').style.display = 'block';
        }
        
        // Initialize Firebase first, then make functions globally available
        console.log('Initializing Firebase...');
        console.log('Database:', window.firebaseDatabase);
        console.log('Available Firebase functions:', {
            ref: typeof ref,
            get: typeof get,
            set: typeof set,
            push: typeof push,
            update: typeof update,
            onValue: typeof onValue
        });
        
        // Firebase functions are already initialized in the module script above
        console.log('Game script loaded, Firebase should be available');

        // Global multiplayer functions (moved here to access Firebase variables)
        function showMultiplayerLobby() {
            console.log('Opening multiplayer lobby...');
            
            // Check if Firebase is ready
            if (!window.firebaseInitialized) {
                console.log('Firebase not ready yet, waiting...');
                setTimeout(() => {
                    if (window.firebaseInitialized) {
                        showMultiplayerLobby();
                    } else {
                        alert('Firebase is still initializing. Please wait a moment and try again.');
                    }
                }, 1000);
                return;
            }
            
            // Hide main menu
            document.getElementById('languageSelect').style.display = 'none';
            
            // Show multiplayer lobby
            document.getElementById('multiplayerLobby').style.display = 'block';
            
            // Debug info
            console.log('Current language:', window.currentLanguage);
            console.log('Firebase database available:', typeof window.firebaseDatabase);
            
            // Check Firebase availability
            if (!window.firebaseInitialized || typeof window.firebaseDatabase === 'undefined') {
                console.error('Firebase not initialized. Available functions:', {
                    firebaseInitialized: window.firebaseInitialized,
                    firebaseDatabase: typeof window.firebaseDatabase,
                    firebaseRef: typeof window.firebaseRef,
                    firebaseSet: typeof window.firebaseSet,
                    firebasePush: typeof window.firebasePush
                });
                alert('Firebase is not available. Multiplayer features are disabled.');
                return;
            }
            
            // Load and display available games
            refreshGameList();
        }

        function showMultiplayerLobby() {
            // Hide all menus
            document.getElementById('languageSelect').style.display = 'none';
            document.getElementById('multiplayerLobby').style.display = 'block';
            
            // Initialize lobby sections
            document.getElementById('gameCreation').style.display = 'block';
            document.getElementById('gameList').style.display = 'block';
            document.getElementById('currentLobby').style.display = 'none';
            
            // Auto-refresh game list when entering lobby
            refreshGameList();
        }

        async function refreshGameList() {
            try {
                // Wait for Firebase to be initialized and authenticated
                if (!window.firebaseInitialized || !window.firebaseDatabase || !window.firebaseAuthenticated) {
                    console.log('Waiting for Firebase initialization and authentication...');
                    await new Promise(resolve => {
                        const checkFirebase = () => {
                            if (window.firebaseInitialized && window.firebaseDatabase && window.firebaseAuthenticated) {
                                resolve();
                            } else {
                                setTimeout(checkFirebase, 100);
                            }
                        };
                        checkFirebase();
                    });
                }
                
                console.log('Refreshing game list...');
                console.log('Current language:', window.currentLanguage);
                console.log('Firebase database:', window.firebaseDatabase);
                
                const gamesRef = window.firebaseRef(window.firebaseDatabase, 'games');
                const snapshot = await window.firebaseGet(window.firebaseQuery(gamesRef, window.firebaseOrderByChild('gameInfo/status'), window.firebaseEqualTo('waiting')));
                
                const gamesList = document.getElementById('gamesList');
                gamesList.innerHTML = '';
                
                if (snapshot.exists()) {
                    const games = snapshot.val();
                    Object.entries(games).forEach(([gameId, gameData]) => {
                        const gameInfo = gameData.gameInfo;
                        
                        // Filter by language (optional - currently showing all)
                        if (gameInfo.language === window.currentLanguage || true) { // Temporarily show all games
                            const gameElement = document.createElement('div');
                            gameElement.className = 'game-item';
                            gameElement.innerHTML = `
                                <h4>${gameInfo.name}</h4>
                                <p>Players: ${gameInfo.currentPlayers}/${gameInfo.maxPlayers}</p>
                                <p>Language: ${gameInfo.language}</p>
                                <button onclick="joinGame('${gameId}')">Join Game</button>
                            `;
                            gamesList.appendChild(gameElement);
                        }
                    });
                }
                
                if (gamesList.innerHTML === '') {
                    gamesList.innerHTML = '<p>No games available. Create a new game!</p>';
                }
            } catch (error) {
                console.error('Error loading games:', error);
                document.getElementById('gamesList').innerHTML = '<p>Error loading games. Please try again.</p>';
            }
        }

        function createMultiplayerGame() {
            console.log('Creating multiplayer game...');
            // Implementation will be added
        }

        function showMainMenu() {
            document.getElementById('multiplayerLobby').style.display = 'none';
            document.getElementById('languageSelect').style.display = 'block';
        }

        function leaveLobby() {
            if (window.multiplayerManager && window.multiplayerManager.gameId) {
                window.multiplayerManager.leaveGame();
            } else {
                showMainMenu();
            }
        }

        function startMultiplayerGame() {
            // Call the multiplayer manager's start function
            if (window.multiplayerManager && window.multiplayerManager.isHost) {
                window.multiplayerManager.startMultiplayerGameplay();
            } else {
                console.error('Only the host can start the game');
                alert('Only the host can start the game');
            }
        }

        function leaveLobby() {
            if (window.multiplayerManager) {
                window.multiplayerManager.leaveGame();
            }
        }

        // Clean up old/stale games from Firebase
        async function cleanupOldGames() {
            try {
                const gamesRef = window.firebaseRef(window.firebaseDatabase, 'games');
                const snapshot = await window.firebaseGet(gamesRef);
                
                if (snapshot.exists()) {
                    const games = snapshot.val();
                    const now = Date.now();
                    const oneHourAgo = now - (60 * 60 * 1000); // 1 hour ago
                    
                    for (const [gameId, gameData] of Object.entries(games)) {
                        // Remove games older than 1 hour or with 0 players
                        if (gameData.gameInfo.createdAt < oneHourAgo || 
                            gameData.gameInfo.currentPlayers === 0) {
                            console.log('Cleaning up old game:', gameId);
                            await window.firebaseRemove(window.firebaseRef(window.firebaseDatabase, `games/${gameId}`));
                        }
                    }
                }
            } catch (error) {
                console.error('Error cleaning up old games:', error);
            }
        }

        // Draw other multiplayer players' spaceships
        function drawMultiplayerSpaceships() {
            if (!window.multiplayerManager || !window.multiplayerManager.isMultiplayer) return;
            
            window.multiplayerManager.players.forEach((playerData, playerId) => {
                // Don't draw our own spaceship again
                if (playerId === window.multiplayerManager.playerId) return;
                
                ctx.save();
                ctx.translate(playerData.x + player.width / 2, playerData.y + player.height / 2);
                ctx.rotate(playerData.rotation || 0);
                
                // Different colors for different players
                const playerColors = ['#ff6600', '#00ff66', '#6600ff', '#ffff00'];
                const colorIndex = Array.from(window.multiplayerManager.players.keys()).indexOf(playerId) % playerColors.length;
                
                // Spaceship body
                ctx.fillStyle = playerColors[colorIndex];
                ctx.fillRect(-player.width / 2, -player.height / 2, player.width, player.height);
                
                // Engine effects (if moving)
                const timeSinceUpdate = Date.now() - (playerData.lastUpdate || 0);
                if (timeSinceUpdate < 200) { // Recently updated = likely moving
                    ctx.fillStyle = `hsl(${Math.random() * 60}, 100%, 50%)`;
                    ctx.fillRect(-player.width / 4, player.height / 2 * 0.6, player.width / 8, player.height * 0.2);
                    ctx.fillRect(0, player.height / 2 * 0.6, player.width / 8, player.height * 0.2);
                }
                
                ctx.restore();
                
                // Player nickname above spaceship
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(playerData.nickname || 'Player', playerData.x + player.width / 2, playerData.y - 5);
            });
        }

        // Update multiplayer UI with all players
        function updateMultiplayerUI() {
            if (!window.multiplayerManager || !window.multiplayerManager.isMultiplayer) return;
            
            const playersListDiv = document.getElementById('playersList');
            if (!playersListDiv) return;
            
            let html = '';
            window.multiplayerManager.players.forEach((playerData, playerId) => {
                const isCurrentPlayer = playerId === window.multiplayerManager.playerId;
                const hostBadge = playerData.isHost ? ' 👑' : '';
                const connectionStatus = playerData.connected ? '🟢' : '🔴';
                
                html += `<div style="margin: 2px 0; font-size: 11px;">
                    ${connectionStatus} ${playerData.nickname}${hostBadge}
                    ${isCurrentPlayer ? ' (You)' : ''}
                    <br><small>Lives: ${playerData.lives || 0}</small>
                </div>`;
            });
            
            playersListDiv.innerHTML = html;
        }

        // Clean up old/stale games from Firebase
        async function cleanupOldGames() {
            try {
                const gamesRef = window.firebaseRef(window.firebaseDatabase, 'games');
                const snapshot = await window.firebaseGet(gamesRef);
                
                if (snapshot.exists()) {
                    const games = snapshot.val();
                    const now = Date.now();
                    const oneHourAgo = now - (60 * 60 * 1000); // 1 hour ago
                    
                    for (const [gameId, gameData] of Object.entries(games)) {
                        // Remove games older than 1 hour or with 0 players
                        if (gameData.gameInfo.createdAt < oneHourAgo || 
                            gameData.gameInfo.currentPlayers === 0) {
                            console.log('Cleaning up old game:', gameId);
                            await window.firebaseRemove(window.firebaseRef(window.firebaseDatabase, `games/${gameId}`));
                        }
                    }
                }
            } catch (error) {
                console.error('Error cleaning up old games:', error);
            }
        }

        // Fix showMultiplayerLobby to hide gameModeSelect
        function showMultiplayerLobby() {
            console.log('Opening multiplayer lobby');
            // Hide game mode selection and show multiplayer lobby
            document.getElementById('gameModeSelect').style.display = 'none';
            document.getElementById('gameCreation').style.display = 'block';
            document.getElementById('gameList').style.display = 'block';
            document.getElementById('currentLobby').style.display = 'none';
            document.getElementById('multiplayerLobby').style.display = 'block';
            
            // Clean up old games and refresh
            cleanupOldGames().then(() => {
                refreshGameList();
            });
        }

        // Update server with local game state changes (for host)
        async function updateServerGameState() {
            if (!window.multiplayerManager || !window.multiplayerManager.isHost || !window.multiplayerManager.gameId) return;
            
            try {
                const gameStateRef = window.firebaseRef(window.firebaseDatabase, `games/${window.multiplayerManager.gameId}/gameState`);
                
                // Prepare game state data
                const gameStateData = {
                    score: gameState.score,
                    totalLives: gameState.lives,
                    enemies: {},
                    bullets: {},
                    powerUps: {}
                };
                
                // Add enemies to sync
                if (typeof enemies !== 'undefined') {
                    enemies.forEach((enemy, index) => {
                        gameStateData.enemies[`enemy_${index}`] = {
                            ...enemy,
                            active: true
                        };
                    });
                }
                
                // Add bullets to sync
                if (typeof player !== 'undefined' && player.bullets) {
                    player.bullets.forEach((bullet, index) => {
                        if (!bullet.isRemote) { // Only sync our own bullets
                            gameStateData.bullets[`bullet_${window.multiplayerManager.playerId}_${index}`] = {
                                ...bullet,
                                playerId: window.multiplayerManager.playerId,
                                active: true
                            };
                        }
                    });
                }
                
                // Add power-ups to sync
                if (typeof powerUps !== 'undefined') {
                    powerUps.forEach((powerUp, index) => {
                        gameStateData.powerUps[`powerup_${index}`] = {
                            ...powerUp,
                            active: true
                        };
                    });
                }
                
                await window.firebaseUpdate(gameStateRef, gameStateData);
            } catch (error) {
                console.error('Error updating server game state:', error);
            }
        }

        // Override startGameFromPreview to hide gameModeSelect
        const originalStartGameFromPreview = window.startGameFromPreview;
        window.startGameFromPreview = function() {
            // Hide all menu screens
            document.getElementById('languageSelect').style.display = 'none';
            document.getElementById('gameModeSelect').style.display = 'none';
            document.getElementById('wasteTypePreview').style.display = 'none';
            document.getElementById('multiplayerLobby').style.display = 'none';
            
            // Call original function if it exists
            if (originalStartGameFromPreview) {
                originalStartGameFromPreview();
            }
        };

        // Expose multiplayer functions globally (AFTER they are defined)
        window.showMultiplayerLobby = showMultiplayerLobby;
        window.createMultiplayerGame = createMultiplayerGame;
        window.refreshGameList = refreshGameList;
        window.showMainMenu = showMainMenu;
        window.leaveLobby = leaveLobby;
        window.startMultiplayerGame = startMultiplayerGame;
        
        // Global multiplayer functions
        function showMultiplayerLobby() {
            console.log('Opening multiplayer lobby...');
            
            // Check if Firebase is ready
            if (!window.firebaseInitialized) {
                console.log('Firebase not ready yet, waiting...');
                setTimeout(() => {
                    if (window.firebaseInitialized) {
                        showMultiplayerLobby();
                    } else {
                        alert('Firebase is still initializing. Please wait a moment and try again.');
                    }
                }, 1000);
                return;
            }
            
            document.getElementById('languageSelect').style.display = 'none';
            document.getElementById('multiplayerLobby').style.display = 'block';
            refreshGameList();
        }
        
        function showMainMenu() {
            // Hide all menus
            document.getElementById('multiplayerLobby').style.display = 'none';
            document.getElementById('currentLobby').style.display = 'none';
            document.getElementById('multiplayerGameUI').style.display = 'none';
            
            // Show language selection
            document.getElementById('languageSelect').style.display = 'block';
            
            // Leave current game if in one
            if (multiplayerManager.isMultiplayer) {
                multiplayerManager.leaveGame();
            }
        }
        
        async function createMultiplayerGame() {
            const nickname = document.getElementById('playerNickname').value.trim();
            if (!nickname) {
                alert('Please enter a nickname');
                return;
            }
            
            console.log('Creating multiplayer game...');
            console.log('Current language:', window.currentLanguage);
            console.log('Firebase database available:', typeof window.firebaseDatabase);
            
            // Check if Firebase is properly initialized
            if (!window.firebaseInitialized || typeof window.firebaseDatabase === 'undefined') {
                console.error('Firebase not initialized. Available functions:', {
                    firebaseInitialized: window.firebaseInitialized,
                    firebaseDatabase: typeof window.firebaseDatabase,
                    firebaseRef: typeof window.firebaseRef,
                    firebaseSet: typeof window.firebaseSet,
                    firebasePush: typeof window.firebasePush
                });
                alert('Firebase is not properly initialized. Please refresh the page and try again.');
                return;
            }
            
            const settings = {
                mode: document.getElementById('gameMode').value,
                maxPlayers: document.getElementById('maxPlayers').value,
                difficulty: document.getElementById('gameDifficulty').value
            };
            
            console.log('Game settings:', settings);
            
            try {
                const success = await multiplayerManager.createGame(settings);
                if (!success) {
                    alert('Failed to create game. Please check the console for details.');
                }
            } catch (error) {
                console.error('Error in createMultiplayerGame:', error);
                alert('Failed to create game: ' + error.message);
            }
        }
        
        async function refreshGameList() {
            const gamesListDiv = document.getElementById('availableGames');
            gamesListDiv.innerHTML = '<div class="loading">Looking for games...</div>';
            
            try {
                console.log('Refreshing game list...');
                console.log('Current language:', window.currentLanguage);
                console.log('Firebase database:', window.firebaseDatabase);
                
                const gamesRef = window.firebaseRef(window.firebaseDatabase, 'games');
                const snapshot = await window.firebaseGet(window.firebaseQuery(gamesRef, window.firebaseOrderByChild('gameInfo/status'), window.firebaseEqualTo('waiting')));
                
                console.log('Snapshot exists:', snapshot.exists());
                
                if (!snapshot.exists()) {
                    gamesListDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">No games available. Create one!</div>';
                    return;
                }
                
                let html = '';
                let gamesFound = 0;
                snapshot.forEach((childSnapshot) => {
                    const gameId = childSnapshot.key;
                    const gameData = childSnapshot.val();
                    const gameInfo = gameData.gameInfo;
                    
                    console.log('Found game:', gameId, gameInfo);
                    gamesFound++;
                    
                    // Filter by language (show all languages for now to debug)
                    if (gameInfo.language === window.currentLanguage || true) { // Temporarily show all games
                        html += `
                            <div style="margin: 10px 0; padding: 15px; border: 1px solid #00ffff; border-radius: 8px; background: rgba(0,255,255,0.1);">
                                <div style="font-weight: bold; margin-bottom: 5px;">${gameInfo.mode.charAt(0).toUpperCase() + gameInfo.mode.slice(1)} Game</div>
                                <div style="font-size: 14px; margin-bottom: 8px;">
                                    Players: ${gameInfo.currentPlayers}/${gameInfo.maxPlayers} | 
                                    Difficulty: ${gameInfo.difficulty} | 
                                    Language: ${gameInfo.language}
                                </div>
                                <button onclick="joinGame('${gameId}')" style="padding: 8px 16px; background: #00ff00; color: #000; border: none; border-radius: 4px; cursor: pointer;">Join Game</button>
                            </div>
                        `;
                    }
                });
                
                console.log('Games found:', gamesFound, 'HTML length:', html.length);
                
                if (html === '') {
                    gamesListDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">No games available. Create one!</div>';
                } else {
                    gamesListDiv.innerHTML = html;
                }
            } catch (error) {
                console.error('Error refreshing game list:', error);
                gamesListDiv.innerHTML = `<div style="padding: 20px; text-align: center; color: #ff0000;">Error loading games: ${error.message}<br>Please check console for details.</div>`;
            }
        }
        
        async function joinGame(gameId) {
            const nickname = document.getElementById('playerNickname').value.trim();
            if (!nickname) {
                alert('Please enter a nickname');
                return;
            }
            
            await multiplayerManager.joinGame(gameId);
        }
        
        async function startMultiplayerGame() {
            if (multiplayerManager.isHost) {
                await multiplayerManager.startMultiplayerGameplay();
            }
        }
        
        function leaveLobby() {
            if (confirm('Are you sure you want to leave the lobby?')) {
                multiplayerManager.leaveGame();
                showMainMenu();
            }
        }
        
        // Expose multiplayer functions globally (AFTER they are defined)
        window.showMultiplayerLobby = showMultiplayerLobby;
        window.createMultiplayerGame = createMultiplayerGame;
        window.refreshGameList = refreshGameList;
        window.showMainMenu = showMainMenu;
        window.leaveLobby = leaveLobby;
        window.startMultiplayerGame = startMultiplayerGame;
        
        // Show waste type preview screen
        function showWasteTypePreview() {
            const previewDiv = document.getElementById('wasteTypePreview');
            const gridDiv = document.getElementById('wasteTypeGrid');
            
            // Update preview text with translations
            document.getElementById('previewTitle').textContent = t('previewTitle');
            document.getElementById('previewSubtitle').textContent = t('previewSubtitle');
            document.getElementById('startGameBtn').textContent = t('startGame');
            document.getElementById('skipBtn').textContent = t('skip');
            
            // Group waste by type
            const wasteByType = {};
            wasteData.forEach(item => {
                if (!wasteByType[item.type]) {
                    wasteByType[item.type] = [];
                }
                wasteByType[item.type].push(item);
            });
            
            // Create waste type cards
            let html = '';
            const typeNames = {
                'gft': { en: 'Organic', nl: 'GFT', zh: '有机垃圾' },
                'papier': { en: 'Paper', nl: 'Papier', zh: '纸类' },
                'pmd': { en: 'Plastic/Metal', nl: 'PMD', zh: '塑料金属' },
                'glas': { en: 'Glass', nl: 'Glas', zh: '玻璃' },
                'textiel': { en: 'Textile', nl: 'Textiel', zh: '纺织品' },
                'rest': { en: 'Residual', nl: 'Restafval', zh: '其他垃圾' },
                'e-waste': { en: 'E-waste', nl: 'E-afval', zh: '电子垃圾' },
                'kca': { en: 'Hazardous', nl: 'KCA', zh: '有害垃圾' },
                'grofvuil': { en: 'Bulky', nl: 'Grofvuil', zh: '大件垃圾' }
            };
            
            Object.keys(wasteByType).forEach(type => {
                const typeName = typeNames[type] ? typeNames[type][currentLanguage] : type;
                const items = wasteByType[type];
                
                const colorMap = {
                    'gft': '#8B4513',
                    'papier': '#4169E1',
                    'pmd': '#FFA500',
                    'glas': '#00CED1',
                    'textiel': '#9370DB',
                    'rest': '#696969',
                    'e-waste': '#DC143C',
                    'kca': '#FF1493',
                    'grofvuil': '#556B2F'
                };
                
                const bgColor = colorMap[type] || '#666666';
                
                // Create HTML for items with emoji and names (show all items, no limit)
                let itemsHtml = '';
                items.forEach(item => {
                    const itemName = item[currentLanguage] || item.en || item.name;
                    itemsHtml += `<div style="display: inline-flex; flex-direction: column; align-items: center; margin: 5px; max-width: 70px;">
                        <span style="font-size: 24px;">${item.emoji}</span>
                        <span style="font-size: 9px; line-height: 1.2; margin-top: 2px; word-wrap: break-word; text-align: center;">${itemName}</span>
                    </div>`;
                });
                
                html += `
                    <div style="background: ${bgColor}; color: white; padding: 10px; border-radius: 8px; text-align: center;">
                        <div style="font-weight: bold; font-size: 16px; margin-bottom: 5px;">${typeName}</div>
                        <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 3px;">${itemsHtml}</div>
                        <div style="font-size: 12px; margin-top: 5px; opacity: 0.8;">${items.length} items</div>
                    </div>
                `;
            });
            
            gridDiv.innerHTML = html;
            previewDiv.style.display = 'block';
        }
        
        // Start game from preview
        function startGameFromPreview() {
            document.getElementById('wasteTypePreview').style.display = 'none';
            startNewSession();
            gameState.lastTime = 0; // Reset lastTime
            animationFrameId = requestAnimationFrame(gameLoop);
            
            // Start background music
            playBackgroundMusic();
            updateWeaponDisplay(); // Initialize weapon display
        }

        // Audio Context for sound effects and background music
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        // Sound effects function
        function playSound(type) {
            try {
                if (type === 'failed') {
                    // Use Web Audio API for failed/error sound
                    const oscillator = audioCtx.createOscillator();
                    const gainNode = audioCtx.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioCtx.destination);
                    oscillator.frequency.value = 150;  // Lower frequency for error
                    oscillator.type = 'square';         // Square wave for harsh sound
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.3);
                    return;
                } else if (type === 'explosion') {
                    // Use Web Audio API for explosion sound
                    const oscillator = audioCtx.createOscillator();
                    const gainNode = audioCtx.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioCtx.destination);
                    oscillator.frequency.value = 100;
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.2);
                    return;
                } else if (type === 'hit') {
                    // Use Web Audio API for hit sound
                    const oscillator = audioCtx.createOscillator();
                    const gainNode = audioCtx.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioCtx.destination);
                    oscillator.frequency.value = 200;
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.1);
                    return;
                }
            } catch (e) {
                console.log('Sound error:', e);
            }
        }
        
        // Background music system
        let currentMusicIndex = 0;
        let shortMusicPlayCount = 0;
        const musicPattern = [
            { file: 'game-music-loop-3-144252.mp3', plays: 1 },
            { file: 'short-game-music-loop-38898.mp3', plays: 3 }
        ];
        let currentPatternIndex = 0;
        let currentPatternPlays = 0;
        let bgMusicAudio = null;
        
        function playBackgroundMusic() {
            if (!bgMusicAudio) {
                bgMusicAudio = new Audio();
                bgMusicAudio.volume = 0.3;
                
                bgMusicAudio.addEventListener('ended', () => {
                    playNextInPattern();
                });
            }
            
            playNextInPattern();
        }
        
        function playNextInPattern() {
            const pattern = musicPattern[currentPatternIndex];
            currentPatternPlays++;
            
            if (currentPatternPlays > pattern.plays) {
                // Move to next pattern
                currentPatternIndex = (currentPatternIndex + 1) % musicPattern.length;
                currentPatternPlays = 1;
            }
            
            const nextPattern = musicPattern[currentPatternIndex];
            bgMusicAudio.src = nextPattern.file;
            bgMusicAudio.play().catch(e => console.log('Music play error:', e));
        }
        
        // Session management
        function startNewSession() {
            gameState.targetType = wasteTypes[Math.floor(Math.random() * wasteTypes.length)];
            gameState.sessionTime = 30;
            updateTargetInfo();
            
            if (gameState.sessionTimer) {
                clearInterval(gameState.sessionTimer);
            }
            
            gameState.sessionTimer = setInterval(() => {
                if (!gameState.paused && !gameState.gameOver && !gameState.victory) {
                    gameState.sessionTime--;
                    updateTargetInfo();
                    
                    if (gameState.sessionTime <= 0) {
                        startNewSession();
                    }
                }
            }, 1000);
        }
        
        function updateTargetInfo() {
            const targetInfo = document.getElementById('targetInfo');
            const sessionTimer = document.getElementById('sessionTimer');
            targetInfo.textContent = `${t('targetWaste')} ${gameState.targetType}`;
            sessionTimer.textContent = `${t('sessionTime')} ${gameState.sessionTime}s`;
        }
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === 'Escape') togglePause();
            if (e.key === ' ') {
                e.preventDefault();
                isShooting = true;
            }
            // Toggle weapon with Q and E keys
            if ((e.key === 'q' || e.key === 'Q') && player.weaponType !== 'missile') {
                player.weaponType = 'missile';
                updateWeaponDisplay();
            }
            if ((e.key === 'e' || e.key === 'E') && player.weaponType !== 'laser') {
                player.weaponType = 'laser';
                updateWeaponDisplay();
            }
            // Secret: Add life with + key (not shown to players)
            if ((e.key === '+' || e.key === '=') && !gameState.gameOver && !gameState.victory) {
                gameState.lives++;
                updateUI();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            if (e.key === ' ') {
                isShooting = false;
                continuousShootStart = 0;
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mousePos.x = (e.clientX - rect.left) * (canvas.width / rect.width);
            mousePos.y = (e.clientY - rect.top) * (canvas.height / rect.height);
        });
        
        canvas.addEventListener('mousedown', () => {
            isShooting = true;
        });
        
        canvas.addEventListener('mouseup', () => {
            isShooting = false;
            continuousShootStart = 0;
        });
        
        document.getElementById('exitBtn').addEventListener('click', () => {
            if (confirm('Exit game?')) {
                location.reload();
            }
        });

        document.getElementById('pauseBtn').addEventListener('click', togglePause);
        
        // Mobile controls
        const mobileButtons = document.querySelectorAll('.control-btn[data-dir]');
        mobileButtons.forEach(btn => {
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const dir = btn.getAttribute('data-dir');
                if (dir === 'up') keys['ArrowUp'] = true;
                if (dir === 'down') keys['ArrowDown'] = true;
                if (dir === 'left') keys['ArrowLeft'] = true;
                if (dir === 'right') keys['ArrowRight'] = true;
            });
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                const dir = btn.getAttribute('data-dir');
                if (dir === 'up') keys['ArrowUp'] = false;
                if (dir === 'down') keys['ArrowDown'] = false;
                if (dir === 'left') keys['ArrowLeft'] = false;
                if (dir === 'right') keys['ArrowRight'] = false;
            });
        });
        
        document.getElementById('shootBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            isShooting = true;
        });
        
        document.getElementById('shootBtn').addEventListener('touchend', (e) => {
            e.preventDefault();
            isShooting = false;
            continuousShootStart = 0;
        });

        document.getElementById('weaponToggleBtn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (player.weaponType === 'missile') {
                player.weaponType = 'laser';
            } else {
                player.weaponType = 'missile';
            }
            updateWeaponDisplay();
        });
        
        function updateWeaponDisplay() {
            document.getElementById('currentWeapon').textContent = player.weaponType.charAt(0).toUpperCase() + player.weaponType.slice(1);
            document.getElementById('weaponToggleBtn').textContent = player.weaponType.charAt(0).toUpperCase() + player.weaponType.slice(1);
        }
        
        function togglePause() {
            if (gameState.gameOver || gameState.victory) return;
            gameState.paused = !gameState.paused;
            document.getElementById('pauseMenu').style.display = gameState.paused ? 'block' : 'none';
            document.getElementById('pauseBtn').textContent = gameState.paused ? 'Resume' : 'Pause';
        }
        
        // Get dynamic enemy size based on item type for more natural shapes
        function getEnemySize(wasteItem) {
            const baseSizeMobile = 40 * getMobileScaleFactor();
            const baseSizeDesktop = 40;
            const baseSize = window.innerWidth <= 768 ? baseSizeMobile : baseSizeDesktop;
            
            // Different size ratios for different waste types to make them more recognizable
            const sizeModifiers = {
                'grofvuil': { width: 1.4, height: 1.2 }, // Bulky items - wider and taller
                'textiel': { width: 1.1, height: 0.8 },  // Textile - slightly wider, shorter
                'papier': { width: 0.9, height: 1.1 },   // Paper - narrower, taller
                'glas': { width: 0.9, height: 1.0 },     // Glass - standard but narrower
                'pmd': { width: 1.0, height: 1.1 },      // Plastic/Metal - slightly taller
                'gft': { width: 1.1, height: 0.9 },      // Organic - wider, shorter
                'e-waste': { width: 1.2, height: 1.0 },  // E-waste - wider
                'kca': { width: 0.8, height: 1.0 },      // Hazardous - smaller, more compact
                'rest': { width: 1.0, height: 1.0 }      // Residual - standard
            };
            
            const modifier = sizeModifiers[wasteItem.type] || sizeModifiers['rest'];
            return {
                width: Math.round(baseSize * modifier.width),
                height: Math.round(baseSize * modifier.height)
            };
        }
        
        // Spawn enemy
        function spawnEnemy() {
            if (bossSpawned || enemies.length > 15) return;
            
            let wasteItem;
            // 80% chance to spawn target waste type
            if (Math.random() < 0.8) {
                // Filter waste items by target type
                const targetWastes = wasteData.filter(w => w.type === gameState.targetType);
                if (targetWastes.length > 0) {
                    wasteItem = targetWastes[Math.floor(Math.random() * targetWastes.length)];
                } else {
                    wasteItem = wasteData[Math.floor(Math.random() * wasteData.length)];
                }
            } else {
                // 20% chance for random waste
                wasteItem = wasteData[Math.floor(Math.random() * wasteData.length)];
            }
            
            const enemy = {
                x: Math.random() * (canvas.width - 40),
                y: -40,
                width: 40,
                height: 40,
                speed: (1 + Math.random() * 2) * getMobileSpeedModifier(),
                health: 10,
                maxHealth: 10,
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 0.1,
                wasteType: wasteItem.type,
                emoji: wasteItem.emoji
            };
            enemies.push(enemy);
        }
        
        // Spawn boss
        function spawnBoss() {
            if (bossSpawned) return;
            bossSpawned = true;
            
            document.getElementById('bossLabel').style.display = 'block';
            document.getElementById('bossHealthBar').style.display = 'block';
            
            boss = {
                x: canvas.width / 2 - 60,
                y: 50,
                width: 120,
                height: 120,
                health: 500,
                maxHealth: 500,
                phase: 1,
                moveDirection: 1,
                speed: 2 * getMobileSpeedModifier(),
                shootTimer: 0,
                shootInterval: 60,
                immuneUntil: 0,              // Timestamp when immunity ends
                isImmune: false,              // Is boss currently immune?
                halfHealthImmunityUsed: false, // Has 50% health immunity been triggered?
                stealthUntil: 0,              // Timestamp when stealth ends
                isInStealth: false,           // Is boss in stealth mode?
                consecutiveHits: 0,           // Counter for consecutive hits
                lastHitTime: 0                // Timestamp of last hit
            };
        }
        
        // Update boss
        function updateBoss() {
            if (!boss) return;
            
            const now = Date.now();
            
            // Check if immunity period has ended
            if (boss.isImmune && now >= boss.immuneUntil) {
                boss.isImmune = false;
                showBossStatusText('Boss vulnerable!');
            }
            
            // Check if stealth period has ended
            if (boss.isInStealth && now >= boss.stealthUntil) {
                boss.isInStealth = false;
                showBossStatusText('Boss visible!');
            }
            
            // Reset consecutive hits if too much time has passed (1 second)
            if (now - boss.lastHitTime > 1000) {
                boss.consecutiveHits = 0;
            }
            
            boss.x += boss.moveDirection * boss.speed;
            if (boss.x <= 0 || boss.x >= canvas.width - boss.width) {
                boss.moveDirection *= -1;
            }
            
            boss.shootTimer++;
            if (boss.shootTimer >= boss.shootInterval) {
                boss.shootTimer = 0;
                throwWasteFromBoss();
            }
            
            // Update boss health bar
            const healthPercent = (boss.health / boss.maxHealth) * 100;
            document.getElementById('bossHealth').style.width = healthPercent + '%';
            
            // Update boss health bar color based on state
            const healthBar = document.getElementById('bossHealth');
            if (boss.isImmune) {
                healthBar.style.background = 'linear-gradient(to right, #9900ff, #ff00ff)'; // Purple for immune
            } else if (boss.isInStealth) {
                healthBar.style.background = 'linear-gradient(to right, #666666, #999999)'; // Gray for stealth
            } else {
                healthBar.style.background = 'linear-gradient(to right, #ff0000, #ff6600)'; // Normal red
            }
            
            if (boss.health <= 0) {
                bossDefeated = true;
                gameState.victory = true;
                const accuracy = gameState.totalKills > 0 
                    ? (gameState.correctKills / gameState.totalKills)
                    : 0;
                const finalScore = Math.round(gameState.score * accuracy * accuracy);
                document.getElementById('victoryScore').innerHTML = `
                    ${t('finalScore')} ${finalScore}<br>
                    <small>Base Score: ${gameState.score} | Accuracy: ${(accuracy * 100).toFixed(1)}%</small>
                `;
                document.getElementById('bossLabel').style.display = 'none';
                document.getElementById('bossHealthBar').style.display = 'none';
                document.getElementById('victory').style.display = 'block';
                // Prompt for nickname and show leaderboard
                setTimeout(() => promptNicknameAndSave(finalScore), 500);
            }
        }
        
        function throwWasteFromBoss() {
            let wasteItem;
            // 80% chance to spawn target waste type (same as regular enemies)
            if (Math.random() < 0.8) {
                const targetWastes = wasteData.filter(w => w.type === gameState.targetType);
                if (targetWastes.length > 0) {
                    wasteItem = targetWastes[Math.floor(Math.random() * targetWastes.length)];
                } else {
                    wasteItem = wasteData[Math.floor(Math.random() * wasteData.length)];
                }
            } else {
                // 20% chance for random waste
                wasteItem = wasteData[Math.floor(Math.random() * wasteData.length)];
            }
            
            const enemy = {
                x: boss.x + boss.width / 2 - 20,
                y: boss.y + boss.height,
                width: 40,
                height: 40,
                speed: 3 * getMobileSpeedModifier(),
                health: 10,
                maxHealth: 10,
                rotation: 0,
                rotationSpeed: (Math.random() - 0.5) * 0.15,
                wasteType: wasteItem.type,
                emoji: wasteItem.emoji,
                fromBoss: true
            };
            enemies.push(enemy);
        }
        
        // Spawn power-up
        function spawnPowerUp(x, y) {
            const types = ['missile', 'laser', 'cooling'];
            const type = types[Math.floor(Math.random() * types.length)];
            powerUps.push({
                x: x,
                y: y,
                width: 30,
                height: 30,
                type: type,
                speed: 2 * getMobileSpeedModifier()
            });
        }
        
        // Shooting
        function shoot() {
            if (gameState.overheated) return;
            
            const now = Date.now();
            const shootDelay = player.weaponType === 'missile' ? 
                (gameState.missilePowerUp ? 150 : 300) : 200;
            
            if (now - lastShootTime < shootDelay) return;
            lastShootTime = now;
            
            if (continuousShootStart === 0) {
                continuousShootStart = now;
            }
            
            // Check for overheating
            const shootDuration = (now - continuousShootStart) / 1000;
            if (shootDuration >= 5) {
                gameState.overheated = true;
                gameState.weaponHeat = 100;
                const cooldownTime = gameState.coolingPowerUp ? 1000 : 2000;
                setTimeout(() => {
                    gameState.overheated = false;
                    continuousShootStart = 0;
                }, cooldownTime);
            } else {
                gameState.weaponHeat = (shootDuration / 5) * 100;
            }
            
            // Calculate tip position based on rotation
            const tipX = player.x + player.width / 2 + Math.sin(player.rotation) * (player.height / 2);
            const tipY = player.y + player.height / 2 - Math.cos(player.rotation) * (player.height / 2);
            
            if (player.weaponType === 'missile') {
                // Fire 2 missiles from the tip
                const offsetLeft = -5; // Offset to left
                const offsetRight = 5; // Offset to right
                
                // Left missile
                const leftX = tipX + Math.cos(player.rotation) * offsetLeft;
                const leftY = tipY + Math.sin(player.rotation) * offsetLeft;
                
                const bulletScale = getMobileScaleFactor();
                player.bullets.push({
                    x: leftX,
                    y: leftY,
                    width: Math.round(4 * bulletScale),
                    height: Math.round(15 * bulletScale),
                    dx: Math.sin(player.rotation) * 8,
                    dy: -Math.cos(player.rotation) * 8,
                    damage: 5,
                    type: 'missile',
                    rotation: player.rotation
                });
                
                // Right missile
                const rightX = tipX + Math.cos(player.rotation) * offsetRight;
                const rightY = tipY + Math.sin(player.rotation) * offsetRight;
                
                player.bullets.push({
                    x: rightX,
                    y: rightY,
                    width: Math.round(4 * bulletScale),
                    height: Math.round(15 * bulletScale),
                    dx: Math.sin(player.rotation) * 8,
                    dy: -Math.cos(player.rotation) * 8,
                    damage: 5,
                    type: 'missile',
                    rotation: player.rotation
                });
            } else {
                // Fire laser from the tip
                const damage = gameState.laserPowerUp ? 10 : 5;
                const baseLaserThickness = gameState.laserPowerUp ? 8 : 4;
                const laserScale = getMobileScaleFactor();
                const thickness = Math.round(baseLaserThickness * laserScale);
                player.bullets.push({
                    x: tipX,
                    y: tipY,
                    width: thickness,
                    height: canvas.height,
                    damage: damage,
                    type: 'laser',
                    duration: 5,
                    rotation: player.rotation
                });
            }
            
            playSound('shoot');
        }
        
        // Sound effects using Web Audio API
        function playSound(type) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;
            
            if (type === 'shoot') {
                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(400, now);
                oscillator.frequency.exponentialRampToValueAtTime(200, now + 0.1);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                oscillator.start(now);
                oscillator.stop(now + 0.1);
            } else if (type === 'explosion') {
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(200, now);
                oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.3);
                gainNode.gain.setValueAtTime(0.5, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                oscillator.start(now);
                oscillator.stop(now + 0.3);
            } else if (type === 'hit') {
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(100, now);
                oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.2);
                gainNode.gain.setValueAtTime(0.4, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            } else if (type === 'powerup') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, now);
                oscillator.frequency.exponentialRampToValueAtTime(880, now + 0.2);
                gainNode.gain.setValueAtTime(0.3, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                oscillator.start(now);
                oscillator.stop(now + 0.2);
            }
        }
        
        // Update game
        function update(deltaTime) {
            if (gameState.paused || gameState.gameOver || gameState.victory) return;
            
            // Update player movement (arrow keys only move, don't rotate)
            let movingLeft = false;
            let movingRight = false;
            
            // Track horizontal movement for body roll effect
            let previousX = player.x;

            if (keys['ArrowLeft'] && player.x > 0) {
                player.x -= player.speed;
                movingLeft = true;
            }
            if (keys['ArrowRight'] && player.x < canvas.width - player.width) {
                player.x += player.speed;
                movingRight = true;
            }
            if (keys['ArrowUp'] && player.y > 0) {
                player.y -= player.speed;
            }
            if (keys['ArrowDown'] && player.y < canvas.height - player.height) {
                player.y += player.speed;
            }
            
            // Calculate horizontal velocity for body roll effect
            player.horizontalVelocity = player.x - previousX;
            
            // Update roll angle based on horizontal movement
            const maxRoll = 0.3; // Maximum roll angle in radians
            const rollSpeed = 0.15; // How fast the roll responds to movement
            const targetRoll = -player.horizontalVelocity * maxRoll / player.speed; // Negative for correct roll direction
            
            // Smoothly interpolate to target roll angle
            player.rollAngle += (targetRoll - player.rollAngle) * rollSpeed;
            
            // Rotation controlled by A and D keys (like spaceshooter.html)
            if ((keys['a'] || keys['A']) && !(keys['d'] || keys['D'])) {
                player.rotation -= player.rotationSpeed;
            } else if ((keys['d'] || keys['D']) && !(keys['a'] || keys['A'])) {
                player.rotation += player.rotationSpeed;
            } else {
                // Smoothly return to upright position when no rotation key is pressed
                if (player.rotation > 0) {
                    player.rotation = Math.max(0, player.rotation - player.rotationSpeed / 2);
                } else if (player.rotation < 0) {
                    player.rotation = Math.min(0, player.rotation + player.rotationSpeed / 2);
                }
            }
            
            // Keep rotation within -PI to PI range for consistency
            if (player.rotation > Math.PI) player.rotation -= Math.PI * 2;
            if (player.rotation < -Math.PI) player.rotation += Math.PI * 2;
            
            // Shooting
            if (isShooting) {
                shoot();
            }
            
            // Cool down weapon heat when not shooting
            if (!isShooting && !gameState.overheated) {
                gameState.weaponHeat = Math.max(0, gameState.weaponHeat - 2);
                continuousShootStart = 0;
            }
            
            // Update bullets
            for (let i = player.bullets.length - 1; i >= 0; i--) {
                const bullet = player.bullets[i];
                
                if (bullet.type === 'missile') {
                    bullet.x += bullet.dx;
                    bullet.y += bullet.dy;
                    
                    // Remove if out of bounds
                    if (bullet.y < -20 || bullet.y > canvas.height + 20 || 
                        bullet.x < -20 || bullet.x > canvas.width + 20) {
                        player.bullets.splice(i, 1);
                    }
                } else if (bullet.type === 'laser') {
                    bullet.duration--;
                    if (bullet.duration <= 0) {
                        player.bullets.splice(i, 1);
                    }
                }
            }
            
            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                enemy.y += enemy.speed;
                enemy.rotation += enemy.rotationSpeed;
                
                if (enemy.y > canvas.height) {
                    enemies.splice(i, 1);
                    continue;
                }
                
                // Check collision with bullets
                for (let j = player.bullets.length - 1; j >= 0; j--) {
                    const bullet = player.bullets[j];
                    
                    let hit = false;
                    if (bullet.type === 'missile') {
                        // Simple collision for missiles
                        if (checkCollision(bullet, enemy)) {
                            hit = true;
                        }
                    } else if (bullet.type === 'laser') {
                        // Laser collision - check if enemy intersects with laser beam
                        const laserTipX = bullet.x;
                        const laserTipY = bullet.y;
                        const length = Math.max(canvas.width, canvas.height) * 1.5;
                        const laserEndX = laserTipX + Math.sin(bullet.rotation) * (-length);
                        const laserEndY = laserTipY - Math.cos(bullet.rotation) * length;
                        
                        // Check distance from enemy center to laser line
                        const ex = enemy.x + enemy.width / 2;
                        const ey = enemy.y + enemy.height / 2;
                        const dist = pointToSegmentDistance(ex, ey, laserTipX, laserTipY, laserEndX, laserEndY);
                        
                        // Increased collision detection range for laser
                        if (dist < enemy.width) {
                            hit = true;
                        }
                    }
                    
                    if (hit) {
                        enemy.health -= bullet.damage;
                        
                        if (bullet.type === 'missile') {
                            player.bullets.splice(j, 1);
                        }
                        
                        if (enemy.health <= 0) {
                            // Track total kills
                            gameState.totalKills++;
                            
                            // Check if correct type
                            if (enemy.wasteType === gameState.targetType) {
                                gameState.correctKills++;
                                gameState.score += 10;
                                gameState.comboKills.push(Date.now());
                                
                                // Remove old combo kills
                                gameState.comboKills = gameState.comboKills.filter(t => Date.now() - t < 2000);
                                
                                // Check for combo
                                if (gameState.comboKills.length >= 5) {
                                    gameState.score += 50;
                                    showComboText(t('comboMega'));
                                } else if (gameState.comboKills.length >= 4) {
                                    gameState.score += 30;
                                    showComboText(t('comboQuad'));
                                } else if (gameState.comboKills.length >= 3) {
                                    gameState.score += 20;
                                    showComboText(t('comboTriple'));
                                } else if (gameState.comboKills.length >= 2) {
                                    gameState.score += 10;
                                    showComboText(t('comboDouble'));
                                }
                                
                                // Check for bonus life every 500 points
                                if (Math.floor(gameState.score / 500) > Math.floor(gameState.lastLifeScore / 500)) {
                                    gameState.lives++;
                                    gameState.lastLifeScore = gameState.score;
                                    showComboText('BONUS LIFE!');
                                }
                                
                                // Play explosion sound for correct hit
                                playSound('explosion');
                            } else {
                                // Wrong waste type - deduct points and play failed sound
                                gameState.score -= 10;
                                playSound('failed');
                            }
                            
                            createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                            
                            // Spawn power-up occasionally
                            if (Math.random() < 0.1) {
                                spawnPowerUp(enemy.x, enemy.y);
                            }
                            
                            enemies.splice(i, 1);
                        }
                        break;
                    }
                }
                
                // Check collision with player
                if (checkCollision(player, enemy)) {
                    gameState.lives--;
                    enemies.splice(i, 1);
                    createExplosion(player.x + player.width / 2, player.y + player.height / 2);
                    playSound('hit');
                    
                    if (gameState.lives <= 0) {
                        gameState.gameOver = true;
                        const accuracy = gameState.totalKills > 0 
                            ? (gameState.correctKills / gameState.totalKills)
                            : 0;
                        const finalScore = Math.round(gameState.score * accuracy * accuracy);
                        document.getElementById('finalScore').innerHTML = `
                            ${t('finalScore')} ${finalScore}<br>
                            <small>Base Score: ${gameState.score} | Accuracy: ${(accuracy * 100).toFixed(1)}%</small>
                        `;
                        document.getElementById('gameOver').style.display = 'block';
                        // Prompt for nickname and show leaderboard
                        setTimeout(() => promptNicknameAndSave(finalScore), 500);
                    }
                }
            }
            
            // Update boss
            if (boss) {
                updateBoss();
                
                // Check collision with bullets
                for (let j = player.bullets.length - 1; j >= 0; j--) {
                    const bullet = player.bullets[j];
                    
                    // Skip collision check if boss is in stealth mode
                    if (boss.isInStealth) {
                        continue;
                    }
                    
                    let hit = false;
                    if (bullet.type === 'missile') {
                        if (checkCollision(bullet, boss)) {
                            hit = true;
                        }
                    } else if (bullet.type === 'laser') {
                        // Laser collision with boss
                        const laserTipX = bullet.x;
                        const laserTipY = bullet.y;
                        const length = Math.max(canvas.width, canvas.height) * 1.5;
                        const laserEndX = laserTipX + Math.sin(bullet.rotation) * (-length);
                        const laserEndY = laserTipY - Math.cos(bullet.rotation) * length;
                        
                        const bx = boss.x + boss.width / 2;
                        const by = boss.y + boss.height / 2;
                        const dist = pointToSegmentDistance(bx, by, laserTipX, laserTipY, laserEndX, laserEndY);
                        
                        // Increased collision detection range for laser
                        if (dist < boss.width / 2) {
                            hit = true;
                        }
                    }
                    
                    if (hit) {
                        const now = Date.now();
                        
                        // Only apply damage if boss is not immune
                        if (!boss.isImmune) {
                            boss.health -= bullet.damage;
                            
                            // Track consecutive hits
                            boss.consecutiveHits++;
                            boss.lastHitTime = now;
                            
                            // Check for 50% health immunity trigger
                            if (!boss.halfHealthImmunityUsed && boss.health <= boss.maxHealth * 0.5) {
                                boss.isImmune = true;
                                boss.halfHealthImmunityUsed = true;
                                boss.immuneUntil = now + 10000; // 10 seconds immunity
                                showBossStatusText('Boss immune for 10s!');
                                console.log('Boss triggered 50% health immunity');
                            }
                            
                            // Check for stealth mode trigger (5 consecutive hits)
                            if (boss.consecutiveHits >= 5 && !boss.isInStealth) {
                                boss.isInStealth = true;
                                boss.stealthUntil = now + 5000; // 5 seconds stealth
                                boss.consecutiveHits = 0; // Reset counter
                                showBossStatusText('Boss entered stealth!');
                                console.log('Boss triggered stealth mode');
                            }
                        } else {
                            // Show immunity message
                            if (Math.random() < 0.1) { // Only show occasionally to avoid spam
                                showBossStatusText('Boss immune!');
                            }
                        }
                        
                        if (bullet.type === 'missile') {
                            player.bullets.splice(j, 1);
                        }
                        
                        createExplosion(boss.x + boss.width / 2, boss.y + boss.height / 2);
                    }
                }
            }
            
            // Update power-ups
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                powerUp.y += powerUp.speed;
                
                if (powerUp.y > canvas.height) {
                    powerUps.splice(i, 1);
                    continue;
                }
                
                if (checkCollision(player, powerUp)) {
                    if (powerUp.type === 'missile') {
                        gameState.missilePowerUp = true;
                        gameState.missilePowerUpTime = 10;
                    } else if (powerUp.type === 'laser') {
                        gameState.laserPowerUp = true;
                        gameState.laserPowerUpTime = 10;
                    } else if (powerUp.type === 'cooling') {
                        gameState.coolingPowerUp = true;
                        gameState.coolingPowerUpTime = 10;
                    }
                    powerUps.splice(i, 1);
                    playSound('powerup');
                }
            }
            
            // Update power-up timers
            if (gameState.missilePowerUpTime > 0) {
                gameState.missilePowerUpTime -= 1/60;
                if (gameState.missilePowerUpTime <= 0) {
                    gameState.missilePowerUp = false;
                }
            }
            if (gameState.laserPowerUpTime > 0) {
                gameState.laserPowerUpTime -= 1/60;
                if (gameState.laserPowerUpTime <= 0) {
                    gameState.laserPowerUp = false;
                }
            }
            if (gameState.coolingPowerUpTime > 0) {
                gameState.coolingPowerUpTime -= 1/60;
                if (gameState.coolingPowerUpTime <= 0) {
                    gameState.coolingPowerUp = false;
                }
            }
            
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Spawn enemies
            if (Math.random() < 0.02 && !bossSpawned) {
                spawnEnemy();
            }
            
            // Check for boss spawn
            if (gameState.score >= 1000 && !bossSpawned && !bossDefeated) {
                spawnBoss();
            }
            
            updateUI();
        }
        
        // Saturn and Ring properties with mobile scaling
        function getSaturnProperties() {
            const scaleFactor = getMobileScaleFactor();
            return {
                x: 0,
                y: 0,
                radius: Math.round(120 * scaleFactor),
                ringInnerRadius: Math.round(150 * scaleFactor),
                ringOuterRadius: Math.round(250 * scaleFactor),
                rotation: 0,
                speed: 0.1
            };
        }
        
        let saturn = getSaturnProperties();
        
        // Satellites orbiting Saturn with mobile scaling
        let satellites = [];
        const numSatellites = 3;
        const satelliteOrbitRadius = saturn.radius + Math.round(50 * getMobileScaleFactor());
        const satelliteSize = Math.round(10 * getMobileScaleFactor());
        for (let i = 0; i < numSatellites; i++) {
            satellites.push({
                angle: (Math.PI * 2 / numSatellites) * i,
                speed: 0.005 + Math.random() * 0.005,
                radius: satelliteSize,
                color: `hsl(${Math.random() * 360}, 70%, 70%)`
            });
        }
        
        // Meteors in Saturn's ring with mobile scaling
        let ringMeteors = [];
        const numRingMeteors = 50;
        const ringMeteorSize = Math.round(2 * getMobileScaleFactor());
        for (let i = 0; i < numRingMeteors; i++) {
            ringMeteors.push({
                angle: Math.random() * Math.PI * 2,
                distance: saturn.ringInnerRadius + Math.random() * (saturn.ringOuterRadius - saturn.ringInnerRadius),
                speed: 0.002 + Math.random() * 0.003,
                radius: ringMeteorSize,
                color: `rgba(180, 180, 180, ${0.5 + Math.random() * 0.5})`
            });
        }
        
        // Stars for background (copied from spaceshooter.html)
        let stars = [];
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * 800,
                y: Math.random() * 600,
                speed: Math.random() * 2 + 1,
                brightness: Math.random()
            });
        }
        
        // Initialize Saturn position - positioned on right side
        saturn.x = saturnCanvas.width - saturn.radius / 2;
        saturn.y = saturnCanvas.height / 2;
        
        // Draw stars (copied from spaceshooter.html)
        function drawStars() {
            stars.forEach(star => {
                saturnCtx.fillStyle = `rgba(255, 255, 255, ${star.brightness})`;
                saturnCtx.fillRect(star.x, star.y, 1, 1);
                star.y += star.speed;
                if (star.y > saturnCanvas.height) {
                    star.y = 0;
                    star.x = Math.random() * saturnCanvas.width;
                }
            });
        }
        
        // Draw Saturn with fixed rings
        function drawSaturn() {
            // Saturn body
            saturnCtx.beginPath();
            saturnCtx.arc(saturn.x, saturn.y, saturn.radius, 0, Math.PI * 2);
            saturnCtx.fillStyle = '#8B7355';
            saturnCtx.fill();
            
            // Draw Saturn rings - fixed size, no shrinking
            saturnCtx.save();
            saturnCtx.translate(saturn.x, saturn.y);
            
            // Draw the outer ring - keep constant size
            saturnCtx.beginPath();
            saturnCtx.ellipse(0, 0, saturn.ringOuterRadius, saturn.ringOuterRadius * 0.2, 0, 0, Math.PI * 2);
            saturnCtx.strokeStyle = '#A0826D';
            saturnCtx.lineWidth = 10;
            saturnCtx.stroke();
            
            // Draw the inner ring - keep constant size
            saturnCtx.beginPath();
            saturnCtx.ellipse(0, 0, saturn.ringInnerRadius, saturn.ringInnerRadius * 0.2, 0, 0, Math.PI * 2);
            saturnCtx.strokeStyle = '#C9B89A';
            saturnCtx.lineWidth = 8;
            saturnCtx.stroke();
            
            saturnCtx.restore();
            
            // Update Saturn rotation for meteor calculations
            saturn.rotation += saturn.speed * 0.01;
        }
        
        // Draw satellite (copied from spaceshooter.html)
        function drawSatellite(satellite) {
            const x = saturn.x + Math.cos(satellite.angle) * satelliteOrbitRadius;
            const y = saturn.y + Math.sin(satellite.angle) * satelliteOrbitRadius;
            
            saturnCtx.beginPath();
            saturnCtx.arc(x, y, satellite.radius, 0, Math.PI * 2);
            saturnCtx.fillStyle = satellite.color;
            saturnCtx.fill();
            
            satellite.angle += satellite.speed;
        }
        
        // Draw ring meteor - fixed orbit, no shrinking
        function drawRingMeteor(meteor) {
            // Keep the orbit size constant by not multiplying by rotation cosine
            const x = saturn.x + Math.cos(meteor.angle) * meteor.distance;
            const y = saturn.y + Math.sin(meteor.angle) * meteor.distance * 0.2; // Keep elliptical shape
            
            saturnCtx.beginPath();
            saturnCtx.arc(x, y, meteor.radius, 0, Math.PI * 2);
            saturnCtx.fillStyle = meteor.color;
            saturnCtx.fill();
            
            meteor.angle += meteor.speed; // Rotate around Saturn
        }
        
        // Draw Saturn background
        function drawSaturnBackground() {
            saturnCtx.fillStyle = '#000011';
            saturnCtx.fillRect(0, 0, saturnCanvas.width, saturnCanvas.height);
            
            // Draw stars
            drawStars();
            
            // Draw Saturn and its rings
            drawSaturn();
            
            // Draw satellites
            satellites.forEach(satellite => {
                drawSatellite(satellite);
            });
            
            // Draw ring meteors
            ringMeteors.forEach(meteor => {
                drawRingMeteor(meteor);
            });
        }

        function gameLoop(timestamp) {
            if (!gameState.lastTime) {
                gameState.lastTime = timestamp;
            }
            const deltaTime = timestamp - gameState.lastTime;

            update(deltaTime);
            draw();
            drawSaturnBackground();

            gameState.lastTime = timestamp;
            if (!gameState.gameOver && !gameState.victory) {
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }
        
        // Draw game
        function draw() {
            // Clear main canvas with minimal transparency for trail effect
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw enemies
            enemies.forEach(enemy => {
                ctx.save();
                ctx.translate(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                ctx.rotate(enemy.rotation);
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(enemy.emoji, 0, 0);
                ctx.restore();
                
                // Draw health bar
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(enemy.x, enemy.y - 10, enemy.width, 5);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(enemy.x, enemy.y - 10, enemy.width * (enemy.health / enemy.maxHealth), 5);
            });
            
            // Draw boss as UFO
            if (boss) {
                ctx.save();
                
                // Apply transparency if in stealth mode
                if (boss.isInStealth) {
                    ctx.globalAlpha = 0.0; // 30% opacity in stealth
                }
                
                // UFO main disc
                let discColor = '#888888';
                let glowColor = '#00ff00';
                
                // Change colors based on boss state
                if (boss.isImmune) {
                    discColor = '#9900ff'; // Purple when immune
                    glowColor = '#ff00ff';
                } else if (boss.isInStealth) {
                    discColor = '#444444'; // Darker when in stealth
                    glowColor = '#666666';
                }
                
                ctx.fillStyle = discColor;
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = boss.isImmune ? 25 : 15; // Stronger glow when immune
                ctx.beginPath();
                ctx.ellipse(boss.x + boss.width / 2, boss.y + boss.height / 2, boss.width * 0.45, boss.height * 0.25, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // UFO dome
                ctx.fillStyle = boss.isImmune ? '#cc66ff' : (boss.isInStealth ? '#666666' : '#aaaaaa');
                ctx.beginPath();
                ctx.ellipse(boss.x + boss.width / 2, boss.y + boss.height * 0.35, boss.width * 0.25, boss.height * 0.2, 0, 0, Math.PI);
                ctx.fill();
                
                // UFO lights (blinking)
                const lightCount = 6;
                for (let i = 0; i < lightCount; i++) {
                    const angle = (i / lightCount) * Math.PI * 2;
                    const lightX = boss.x + boss.width / 2 + Math.cos(angle) * boss.width * 0.35;
                    const lightY = boss.y + boss.height / 2 + Math.sin(angle) * boss.height * 0.15;
                    
                    let lightColor;
                    if (boss.isImmune) {
                        lightColor = (Date.now() / 200 + i) % 2 < 1 ? '#ff00ff' : '#9900ff';
                    } else if (boss.isInStealth) {
                        lightColor = (Date.now() / 200 + i) % 2 < 1 ? '#666666' : '#333333';
                    } else {
                        lightColor = (Date.now() / 200 + i) % 2 < 1 ? '#00ff00' : '#ff0000';
                    }
                    
                    ctx.fillStyle = lightColor;
                    ctx.shadowColor = lightColor;
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.arc(lightX, lightY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Draw immunity shield effect
                if (boss.isImmune) {
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#ff00ff';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(boss.x + boss.width / 2, boss.y + boss.height / 2, boss.width * 0.6, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1; // Reset alpha
                ctx.restore();
            }
            
            // Draw player (symmetrical spaceship - copied from spaceshooter.html)
            ctx.save();
            ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
            ctx.rotate(player.rotation);
            
            // Calculate wing scale factors based on roll angle for body roll effect
            const baseWingScale = 1.0;
            const rollEffectStrength = 0.4; // How much the wings scale
            const leftWingScale = baseWingScale + (player.rollAngle * rollEffectStrength);
            const rightWingScale = baseWingScale - (player.rollAngle * rollEffectStrength);
            
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(0, -player.height / 2); // Top point (nose)
            
            // Left wing (scaled based on roll)
            ctx.lineTo(-player.width / 2 * leftWingScale, player.height / 2); // Bottom-left wing tip
            ctx.lineTo(-player.width / 4, player.height / 2 * 0.6); // Inner-left wing root
            
            // Right wing (scaled based on roll)  
            ctx.lineTo(player.width / 4, player.height / 2 * 0.6); // Inner-right wing root
            ctx.lineTo(player.width / 2 * rightWingScale, player.height / 2); // Bottom-right wing tip
            
            ctx.closePath();
            ctx.fill();
            
            // Engine glow (scaled based on roll angle)
            ctx.fillStyle = '#ff4400';
            const engineWidth = player.width / 2;
            const engineLeftScale = baseWingScale + (player.rollAngle * rollEffectStrength * 0.5); // Less effect than wings
            const engineRightScale = baseWingScale - (player.rollAngle * rollEffectStrength * 0.5);
            
            // Left side of engine
            const leftEngineWidth = engineWidth / 2 * engineLeftScale;
            ctx.fillRect(-player.width / 4, player.height / 2 * 0.6, leftEngineWidth, player.height * 0.2);
            
            // Right side of engine
            const rightEngineWidth = engineWidth / 2 * engineRightScale;
            ctx.fillRect(0, player.height / 2 * 0.6, rightEngineWidth, player.height * 0.2);
            
            ctx.shadowBlur = 0;
            ctx.restore();
            
            // Draw bullets
            player.bullets.forEach(bullet => {
                if (bullet.type === 'missile') {
                    ctx.save();
                    ctx.translate(bullet.x, bullet.y);
                    ctx.rotate(bullet.rotation);
                    ctx.fillStyle = '#ffff00';
                    ctx.shadowColor = '#ffff00';
                    ctx.shadowBlur = 10;
                    ctx.fillRect(-2, -4, 4, 8);
                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else if (bullet.type === 'laser') {
                    // Draw laser from tip position with rotation
                    const thickness = bullet.width;
                    const length = Math.max(canvas.width, canvas.height) * 1.5;
                    
                    ctx.save();
                    ctx.translate(bullet.x, bullet.y);
                    ctx.rotate(bullet.rotation);
                    
                    // Main laser beam
                    ctx.fillStyle = '#ff0000';
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = thickness * 2;
                    ctx.fillRect(-thickness/2, 0, thickness, -length);
                    
                    // Inner core
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-thickness/4, 0, thickness/2, -length);
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
            });
            
            // Draw power-ups
            powerUps.forEach(powerUp => {
                ctx.fillStyle = powerUp.type === 'missile' ? '#ffff00' : 
                               powerUp.type === 'laser' ? '#ff0000' : '#00ffff';
                ctx.fillRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(powerUp.type === 'missile' ? '🚀' : 
                            powerUp.type === 'laser' ? '⚡' : '❄️', 
                            powerUp.x + powerUp.width / 2, powerUp.y + powerUp.height / 2);
            });
            
            // Draw particles
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.fillRect(p.x, p.y, p.size, p.size);
                ctx.globalAlpha = 1;
            });
        }
        
        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.height > obj2.y;
        }
        
        // Helper function for laser collision detection
        function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            
            if (lenSq !== 0) {
                param = dot / lenSq;
            }
            
            let xx, yy;
            
            if (param < 0) {
                xx = x1;
                yy = y1;
            } else if (param > 1) {
                xx = x2;
                yy = y2;
            } else {
                xx = x1 + param * C;
                yy = y1 + param * D;
            }
            
            const dx = px - xx;
            const dy = py - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
        
        function createExplosion(x, y) {
            const particleScale = getMobileScaleFactor();
            for (let i = 0; i < 20; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    size: Math.round((Math.random() * 4 + 2) * particleScale),
                    life: 30,
                    color: `hsl(${Math.random() * 60 + 10}, 100%, 50%)`
                });
            }
        }
        
        function showComboText(text) {
            // Show combo text on screen (centered)
            const comboDiv = document.createElement('div');
            comboDiv.style.position = 'absolute';
            comboDiv.style.top = '50%';
            comboDiv.style.left = '50%';
            comboDiv.style.transform = 'translate(-50%, -50%)';
            comboDiv.style.fontSize = '36px';
            comboDiv.style.fontWeight = 'bold';
            comboDiv.style.color = '#ffff00';
            comboDiv.style.textShadow = '0 0 10px #ffff00';
            comboDiv.style.zIndex = '200';
            comboDiv.textContent = text;
            document.getElementById('gameContainer').appendChild(comboDiv);
            
            setTimeout(() => {
                comboDiv.remove();
            }, 2000);
        }
        
        function showBossStatusText(text) {
            // Show boss status text (top of screen, different position from combo)
            const statusDiv = document.createElement('div');
            statusDiv.style.position = 'absolute';
            statusDiv.style.top = '30%';  // Higher position
            statusDiv.style.left = '50%';
            statusDiv.style.transform = 'translate(-50%, -50%)';
            statusDiv.style.fontSize = '28px';
            statusDiv.style.fontWeight = 'bold';
            statusDiv.style.color = '#ff00ff';  // Different color (magenta)
            statusDiv.style.textShadow = '0 0 10px #ff00ff';
            statusDiv.style.zIndex = '200';
            statusDiv.textContent = text;
            document.getElementById('gameContainer').appendChild(statusDiv);
            
            setTimeout(() => {
                statusDiv.remove();
            }, 2000);
        }
        
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('lives').textContent = gameState.lives;
            
            // Calculate and display accuracy
            const accuracy = gameState.totalKills > 0 
                ? ((gameState.correctKills / gameState.totalKills) * 100).toFixed(1)
                : 0;
            document.getElementById('accuracy').textContent = accuracy + '%';
            
            // Update weapon display
            const weaponName = player.weaponType === 'missile' ? 'Missile' : 'Laser';
            document.getElementById('currentWeapon').textContent = weaponName;
            
            // Update heat bar
            document.getElementById('heatBar').style.width = gameState.weaponHeat + '%';
            
            // Update power-up display
            const powerUpDiv = document.getElementById('powerUps');
            let powerUpText = '';
            if (gameState.missilePowerUp) {
                powerUpText += `${t('powerUpMissile')}: ${Math.ceil(gameState.missilePowerUpTime)}s<br>`;
            }
            if (gameState.laserPowerUp) {
                powerUpText += `${t('powerUpLaser')}: ${Math.ceil(gameState.laserPowerUpTime)}s<br>`;
            }
            if (gameState.coolingPowerUp) {
                powerUpText += `${t('powerUpCooling')}: ${Math.ceil(gameState.coolingPowerUpTime)}s<br>`;
            }
            powerUpDiv.innerHTML = powerUpText;
        }
        
        // Handle URL parameters for language selection
        function handleUrlParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const langParam = urlParams.get('lang');
            if (langParam && ['en', 'nl', 'zh'].includes(langParam)) {
                // Set the language but don't auto-select - show language screen first
                currentLanguage = langParam;
                // Show language selection screen anyway
                document.getElementById('languageSelect').style.display = 'block';
            }
        }
        
        // Initialize URL parameter handling when page loads
        document.addEventListener('DOMContentLoaded', handleUrlParameters);
        
        // Nickname and leaderboard functions
        function promptNicknameAndSave(finalScore) {
            const nicknamePrompt = document.getElementById('nicknamePrompt');
            const input = document.getElementById('nicknameInput');
            const submitBtn = document.getElementById('submitNicknameBtn');
            
            nicknamePrompt.style.display = 'block';
            input.focus();
            
            function submit() {
                const nickname = input.value.trim();
                if (nickname) {
                    saveScoreAndShowLeaderboard(nickname, finalScore);
                    nicknamePrompt.style.display = 'none';
                } else {
                    alert('Please enter a nickname!');
                }
            }
            
            submitBtn.onclick = submit;
            input.onkeydown = function(e) {
                if (e.key === 'Enter') submit();
            };
        }
        
        async function saveScoreAndShowLeaderboard(nickname, score) {
            try {
                // Save score to Firebase
                await window.firebaseDB.addScore(nickname, score);
                
                // Get top scores and show leaderboard
                const topScores = await window.firebaseDB.getTopScores(10);
                showLeaderboard(topScores, nickname, score);
            } catch (error) {
                console.error('Error saving score:', error);
                // Still show local leaderboard even if Firebase fails
                showLeaderboard([], nickname, score);
            }
        }
        
        function showLeaderboard(scores, playerName, playerScore) {
            const leaderboard = document.getElementById('leaderboard');
            const table = document.getElementById('leaderboardTable');
            const playerEntry = document.getElementById('playerEntry');
            
            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += '<tr style="background: rgba(0,255,255,0.2);"><th style="padding: 8px; border: 1px solid #00ffff;">Rank</th><th style="padding: 8px; border: 1px solid #00ffff;">Name</th><th style="padding: 8px; border: 1px solid #00ffff;">Score</th></tr>';
            
            scores.forEach((score, index) => {
                const isPlayer = score.name === playerName && score.score === playerScore;
                const rowStyle = isPlayer ? 'background: rgba(255,255,0,0.3);' : '';
                html += `<tr style="${rowStyle}"><td style="padding: 8px; border: 1px solid #00ffff;">${index + 1}</td><td style="padding: 8px; border: 1px solid #00ffff;">${score.name}</td><td style="padding: 8px; border: 1px solid #00ffff;">${score.score}</td></tr>`;
            });
            
            html += '</table>';
            table.innerHTML = html;
            
            // Show player's entry if not in top 10
            const playerInTop10 = scores.some(score => score.name === playerName && score.score === playerScore);
            if (!playerInTop10) {
                playerEntry.textContent = `Your Score: ${playerName} - ${playerScore}`;
            } else {
                playerEntry.textContent = '';
            }
            
            leaderboard.style.display = 'block';
        }
        
        function closeLeaderboard() {
            document.getElementById('leaderboard').style.display = 'none';
            if (gameState.gameOver) {
                document.getElementById('gameOver').style.display = 'block';
            }
            if (gameState.victory) {
                document.getElementById('victory').style.display = 'block';
            }
        }
    </script>
</body>
</html>
