<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>MatchWaste - Match 3 Puzzle Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }

        #gameContainer {
            background: linear-gradient(180deg, #1e3c72 0%, #2a5298 100%);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 500px;
            display: none;
        }

        h1 {
            text-align: center;
            color: #fff;
            font-size: 36px;
            margin: 0 0 20px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        #gameInfo {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            color: #fff;
            font-size: 18px;
            flex-wrap: wrap;
        }

        #time,
        #moves,
        #matchCount {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        #gameBoard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 15px;
        }

        .gem {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .gem:hover {
            transform: scale(1.1);
            background: rgba(255, 255, 255, 0.2);
        }

        .gem.selected {
            background: rgba(255, 255, 0, 0.5);
            border: 3px solid #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }

        .gem.matched {
            animation: blast 0.5s ease;
        }

        .gem.empty {
            background: transparent;
            border: 2px dashed rgba(255, 255, 255, 0.2);
        }

        @keyframes blast {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.3) rotate(180deg);
                background: rgba(255, 255, 255, 0.8);
            }

            100% {
                transform: scale(0);
                opacity: 0;
            }
        }

        .falling {
            animation: fall 0.5s ease;
        }

        @keyframes fall {
            from {
                transform: translateY(-100px);
            }

            to {
                transform: translateY(0);
            }
        }

        #controls {
            margin-top: 20px;
            text-align: center;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        #gameOver,
        #victory {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: white;
            max-width: 400px;
        }

        .modal h2 {
            font-size: 48px;
            margin: 0 0 20px 0;
        }

        .modal p {
            font-size: 24px;
            margin: 20px 0;
        }

        #hint {
            margin-top: 15px;
            color: #fff;
            text-align: center;
            font-size: 14px;
            opacity: 0.8;
        }

        .waste-type-0 {
            background: rgba(139, 69, 19, 0.3);
        }

        .waste-type-1 {
            background: rgba(65, 105, 225, 0.3);
        }

        .waste-type-2 {
            background: rgba(255, 165, 0, 0.3);
        }

        .waste-type-3 {
            background: rgba(0, 206, 209, 0.3);
        }

        .waste-type-4 {
            background: rgba(147, 112, 219, 0.3);
        }

        .waste-type-5 {
            background: rgba(105, 105, 105, 0.3);
        }

        .waste-type-6 {
            background: rgba(220, 20, 60, 0.3);
        }

        .waste-type-7 {
            background: rgba(255, 20, 147, 0.3);
        }

        .waste-type-8 {
            background: rgba(85, 107, 47, 0.3);
        }

        /* ========== FULL-SCREEN MODAL SOLUTION FOR MOBILE ========== */
        @media (max-width: 1024px) {

            /* Body locked when modal is open */
            body.modal-open {
                overflow: hidden !important;
                position: fixed !important;
                width: 100% !important;
                height: 100% !important;
            }

            /* FULL-SCREEN MODAL CONTAINER */
            #wasteTypePreview {
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                right: 0 !important;
                bottom: 0 !important;
                width: 100vw !important;
                height: 100vh !important;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
                z-index: 10000 !important;
                display: flex !important;
                flex-direction: column !important;
                margin: 0 !important;
                padding: 0 !important;
                border-radius: 0 !important;
                /* Changed to hidden to allow child scrolling */
                overflow: hidden !important;
                max-width: none !important;
                box-shadow: none !important;
                /* REMOVED pointer-events: none - this was blocking all clicks! */
            }

            /* Modal header with title - target both h2 and h3 */
            #wasteTypePreview>h2,
            #wasteTypePreview>h3,
            #wasteTypePreview #previewTitle {
                background: rgba(0, 0, 0, 0.2) !important;
                color: white !important;
                margin: 0 !important;
                padding: 20px !important;
                text-align: center !important;
                font-size: 24px !important;
                border-bottom: 2px solid rgba(255, 255, 255, 0.3) !important;
                flex-shrink: 0 !important;
                order: 1 !important;
                /* Re-enable pointer events for header */
                pointer-events: auto !important;
            }

            /* Modal subtitle */
            #wasteTypePreview>p,
            #wasteTypePreview #previewSubtitle {
                background: rgba(0, 0, 0, 0.1) !important;
                color: rgba(255, 255, 255, 0.9) !important;
                margin: 0 !important;
                padding: 10px 20px !important;
                text-align: center !important;
                font-size: 16px !important;
                border-bottom: 1px solid rgba(255, 255, 255, 0.2) !important;
                flex-shrink: 0 !important;
                order: 2 !important;
                /* Re-enable pointer events for subtitle */
                pointer-events: auto !important;
            }

            /* INDEPENDENT SCROLLING GRID CONTAINER */
            #wasteTypeGridPreview {
                flex: 1 !important;
                overflow-y: auto !important;
                overflow-x: hidden !important;
                padding: 20px !important;
                display: grid !important;
                /* Default mobile layout: auto-fit */
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)) !important;
                grid-auto-rows: auto !important;
                gap: 20px !important;
                row-gap: 25px !important;
                align-content: start !important;
                align-items: stretch !important;
                background: transparent !important;
                margin: 0 !important;
                max-height: none !important;
                height: auto !important;
                order: 3 !important;
                padding-bottom: 140px !important;
                pointer-events: auto !important;
            }

            /* Ensure grid items (cards) behave correctly - CONSOLIDATED RULES */
            #wasteTypeGridPreview>div {
                /* Layout & Sizing */
                height: auto !important;
                min-height: min-content !important;
                width: 100% !important;
                box-sizing: border-box !important;
                overflow: visible !important;

                /* Flexbox for internal layout */
                display: flex !important;
                flex-direction: column !important;
                justify-content: flex-start !important;
                /* Start from top */
                align-items: stretch !important;
                /* Stretch to fill width */

                /* Visual Styling */
                border-radius: 12px !important;
                padding: 15px !important;
                text-align: center !important;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2) !important;
                transition: transform 0.2s ease !important;
                cursor: pointer !important;

                /* Let the waste type color classes (from JavaScript) define the background */
                /* Background color is set inline by JS */
            }

            #wasteTypeGridPreview>div:active,
            #wasteTypeGridPreview>div:hover {
                transform: scale(1.02) !important;
                /* Reduced scale to prevent overlap */
                z-index: 10 !important;
                /* Bring to front on hover */
            }

            /* PERMANENTLY DOCKED BUTTON BAR */
            #gameButtonContainer {
                max-width: none !important;
                z-index: 10002 !important;
                /* Increased z-index to be above everything */
                background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%) !important;
                padding: 20px !important;
                padding-bottom: max(20px, env(safe-area-inset-bottom)) !important;
                margin: 0 !important;
                border-radius: 0 !important;
                border-top: 3px solid rgba(255, 255, 255, 0.4) !important;
                box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.3) !important;
                display: flex !important;
                gap: 15px !important;
                justify-content: center !important;
                flex-shrink: 0 !important;
                order: 4 !important;
                /* CRITICAL: Re-enable pointer events for buttons to be clickable */
                pointer-events: auto !important;
                box-sizing: border-box !important;
            }

            /* Prominent Start Game button */
            #startGameBtn {
                flex: 2 !important;
                max-width: 200px !important;
                margin: 0 !important;
                font-size: 18px !important;
                padding: 18px 20px !important;
                background: #00ff00 !important;
                color: #000 !important;
                border: 3px solid #00aa00 !important;
                font-weight: bold !important;
                text-transform: uppercase !important;
                letter-spacing: 1px !important;
                border-radius: 12px !important;
                box-shadow: 0 4px 15px rgba(0, 255, 0, 0.3) !important;
                min-height: 60px !important;
                cursor: pointer !important;
                touch-action: manipulation !important;
            }

            #skipBtn {
                flex: 1 !important;
                max-width: 120px !important;
                margin: 0 !important;
                background: #ffaa00 !important;
                color: #000 !important;
                border: 2px solid #cc7700 !important;
                font-weight: bold !important;
                border-radius: 12px !important;
                font-size: 16px !important;
                padding: 18px 15px !important;
                min-height: 60px !important;
                cursor: pointer !important;
                touch-action: manipulation !important;
            }

            /* Touch-friendly button styling */
            button {
                min-height: 50px !important;
                min-width: 120px !important;
                font-size: 16px !important;
                border-radius: 10px !important;
                transition: all 0.2s ease !important;
                cursor: pointer !important;
                touch-action: manipulation !important;
                -webkit-tap-highlight-color: transparent !important;
            }

            button:active {
                transform: scale(0.95) !important;
            }

            /* Ensure buttons are clickable on mobile */
            #startGameBtn:active,
            #skipBtn:active {
                background: rgba(0, 255, 0, 0.8) !important;
                transform: scale(0.95) !important;
            }

            #skipBtn:active {
                background: rgba(255, 170, 0, 0.8) !important;
            }
        }

        /* Specific adjustments for smaller mobile screens */
        @media (max-width: 600px) {
            #gameContainer {
                padding: 15px;
                max-width: 95%;
            }

            .gem {
                width: 40px;
                height: 40px;
                font-size: 24px;
            }

            h1 {
                font-size: 28px;
            }

            /* Smaller grid items on very small screens */
            #wasteTypeGrid,
            #wasteTypeGridPreview {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: 10px;
            }

            /* Slightly smaller buttons on tiny screens */
            button {
                font-size: 16px;
                padding: 15px 20px;
                min-height: 50px;
            }

            #startGameBtn {
                font-size: 18px !important;
                padding: 18px !important;
            }
        }

        /* Hide game board when waste type preview is shown */
        #wasteTypePreview:not([style*="display: none"])~#gameContainer {
            display: none;
        }

        /* General menu styling */
        .menu {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            max-width: 500px;
            color: white;
            text-align: center;
        }

        /* Additional mobile-specific components */
        @media (max-width: 1024px) {

            /* Leaderboard mobile positioning */
            #leaderboard {
                position: fixed;
                bottom: 0;
                top: auto;
                left: 0;
                right: 0;
                transform: none;
                max-height: 60vh;
                overflow-y: auto;
                border-radius: 15px 15px 0 0;
                z-index: 1001;
                margin: 0;
            }

            #leaderboardTable {
                max-height: 40vh;
                overflow-y: auto;
            }

            /* Game mode selection mobile improvements */
            #gameModeSelect {
                padding: 20px;
            }

            #gameModeSelect button {
                width: 90%;
                margin: 10px auto;
                display: block;
                min-height: 55px;
                font-size: 18px;
            }

            /* Waste types guide in main menu mobile adjustments */
            #gameModeSelect>div:last-child {
                margin-top: 25px;
                padding-top: 20px;
                border-top: 2px solid rgba(255, 255, 255, 0.2);
            }

            /* Better spacing for waste type items in grid */
            #wasteTypeGrid>div,
            #wasteTypeGridPreview>div {
                padding: 12px;
                border-radius: 8px;
                transition: transform 0.2s ease;
            }

            #wasteTypeGrid>div:hover,
            #wasteTypeGridPreview>div:hover {
                transform: scale(1.05);
            }
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <h1>‚ô¢ MatchWaste ‚ô¢</h1>
        <div id="gameInfo">
            <div id="time">Time: <span id="timeValue">00:00</span></div>
            <div id="moves">Moves: <span id="movesValue">0</span></div>
            <div id="matchCount">Matches: <span id="matchCountValue">0</span></div>
        </div>
        <div id="gameBoard"></div>
        <div id="controls">
            <button onclick="newGame()">New Game</button>
            <button onclick="showHint()" id="hintBtn" disabled>Hint</button>
        </div>
        <div id="hint">Click two adjacent emojis to swap them. Match 3+ of the same type to clear them! Clear all waste
            to win!</div>
    </div>

    <!-- Language selection menu -->
    <div id="languageSelect" class="menu" style="display:none;">
        <h1>MatchWaste</h1>
        <p>Select Language / Selecteer taal / ÈÄâÊã©ËØ≠Ë®Ä</p>
        <button onclick="selectLanguage('en')">English</button>
        <button onclick="selectLanguage('nl')">Nederlands</button>
        <button onclick="selectLanguage('zh')">‰∏≠Êñá</button>
    </div>

    <!-- Game mode selection menu -->
    <div id="gameModeSelect" class="menu" style="display:none;">
        <h1>MatchWaste</h1>
        <h3 style="color: white;">Choose Game Mode</h3>
        <button onclick="showMultiplayerLobby()"
            style="background: linear-gradient(45deg, #ff6600, #ff9900); margin-bottom: 10px; padding: 15px 30px; font-size: 18px;">üéÆ
            Multiplayer</button>
        <br>
        <button onclick="startSinglePlayer()"
            style="background: linear-gradient(45deg, #00ff00, #00cc00); padding: 15px 30px; font-size: 18px;">üë§ Single
            Player</button>
        <br><br>
        <button onclick="showLanguageSelect()" style="background: #666; padding: 10px 20px;">‚Üê Back to Language</button>

        <!-- Waste Type Guide moved here -->
        <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.3);">
            <h3 style="color: white;">Waste Types Guide</h3>
            <p style="font-size: 14px; color: rgba(255,255,255,0.8); margin-bottom: 15px;">Learn the waste categories
                before you start!</p>
            <div id="wasteTypeGrid"
                style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; max-height: 400px; overflow-y: auto; padding: 10px;">
                <!-- Waste types will be dynamically inserted here -->
            </div>
        </div>
    </div>

    <div id="gameOver">
        <div class="modal">
            <h2 id="gameOverTitle">üí• Game Over!</h2>
            <p id="gameOverText">The waste has reached the top!</p>
            <p>Your Time: <span id="finalTime"></span></p>
            <button onclick="newGame()" id="gameOverRestartBtn">Play Again</button>
            <button onclick="location.reload()" id="gameOverChangeBtn">Main Menu</button>
        </div>
    </div>

    <div id="victory">
        <div class="modal">
            <h2 id="victoryTitle">üéâ Victory!</h2>
            <p id="victoryText">You've cleared all the waste!</p>
            <p>Your Time: <span id="victoryTime"></span></p>
            <button onclick="newGame()" id="victoryRestartBtn">Play Again</button>
            <button onclick="location.reload()" id="victoryChangeBtn">Main Menu</button>
        </div>
    </div>

    <div id="wasteTypePreview" class="menu" style="display:none;">
        <h2 id="previewTitle" style="text-align: center;">Waste Types Guide</h2>
        <p id="previewSubtitle" style="font-size: 14px; margin-bottom: 20px; text-align: center;">Learn the waste
            categories before you start!</p>
        <div id="wasteTypeGridPreview"
            style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; max-height: 400px; overflow-y: auto; padding: 10px;">
            <!-- Waste types will be dynamically inserted here -->
        </div>
        <div id="gameButtonContainer"
            style="margin-top: 20px; text-align: center; position: sticky; bottom: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 15px; border-radius: 10px; border-top: 2px solid rgba(255,255,255,0.3);">
            <button id="startGameBtn" onclick="startGameFromPreview()"
                style="background: #00ff00; color: #000; font-weight: bold; padding: 15px 30px; font-size: 18px; margin: 5px; border: 2px solid #00aa00; border-radius: 8px; cursor: pointer; min-width: 140px;">Start
                Game</button>
            <button id="skipBtn"
                style="background: #ffaa00; color: #000; padding: 12px 20px; border: 2px solid #cc7700; border-radius: 8px; cursor: pointer; margin: 5px;">Skip</button>
        </div>
    </div>

    <!-- Pause menu -->
    <div id="pauseMenu" class="menu" style="display:none;">
        <h1 id="pauseTitle">Paused</h1>
        <button onclick="togglePause()">Resume</button>
        <button onclick="location.reload()">Restart</button>
        <button onclick="location.reload()">Change Language</button>
    </div>

    <!-- Multiplayer Lobby -->
    <div id="multiplayerLobby" class="menu" style="display:none;">
        <h2>Multiplayer Lobby</h2>
        <p>Coming Soon!</p>
        <button onclick="showMainMenu()">Back</button>
    </div>

    <div id="nicknamePrompt" class="menu" style="display:none;">
        <h2>Enter Your Nickname</h2>
        <input type="text" id="nicknameInput" maxlength="15" placeholder="Your Name"
            style="padding: 10px; font-size: 18px; margin: 10px 0; width: 80%;">
        <br>
        <button id="submitNicknameBtn" onclick="saveScore()" style="margin-top: 10px;">Submit</button>
    </div>

    <div id="leaderboard" class="menu" style="display:none;">
        <h2>Leaderboard</h2>
        <div id="leaderboardTable" style="margin: 20px 0; max-height: 400px; overflow-y: auto;"></div>
        <div id="playerEntry" style="margin: 10px 0; color: #ffff00; font-weight: bold;"></div>
        <button onclick="closeLeaderboard()">Continue</button>
    </div>

    <script>
        // Game translations
        const translations = {
            en: {
                gameOver: 'Game Over',
                victory: 'Victory!',
                paused: 'Paused',
                finalTime: 'Final Time:',
                playAgain: 'Play Again',
                changeLanguage: 'Change Language',
                resume: 'Resume',
                restart: 'Restart',
                previewTitle: 'Waste Types Guide',
                previewSubtitle: 'Learn the waste categories before you start!',
                startGame: 'Start Game',
                skip: 'Skip',
                selectLanguage: 'Select Language',
                singlePlayer: 'Single Player',
                multiplayer: 'Multiplayer',
                backToLanguage: '‚Üê Back to Language',
                gameOverTitle: 'Game Over',
                victoryTitle: 'Victory!',
                pauseTitle: 'Paused',
                gameOverRestartBtn: 'Play Again',
                gameOverChangeBtn: 'Change Language',
                victoryRestartBtn: 'Play Again',
                victoryChangeBtn: 'Change Language',
                enterNickname: 'Enter Your Nickname',
                submit: 'Submit',
                leaderboard: 'Leaderboard',
                continue: 'Continue',
                gameInstructions: 'Click two adjacent emojis to swap them. Match 3+ of the same type to clear them! Clear all waste to win!',
                newGame: 'New Game',
                hint: 'Hint',
                time: 'Time',
                moves: 'Moves',
                matches: 'Matches',
                gameMode: 'Choose Game Mode',
                wasteType0: 'E-waste',
                wasteType1: 'Electronics',
                wasteType2: 'Mixed Items',
                wasteType3: 'Large Appliances',
                wasteType4: 'Hazardous',
                wasteType5: 'Glass',
                wasteType6: 'Paper',
                wasteType7: 'Plastic/Metal',
                wasteType8: 'Textile',
                wasteType9: 'Organic'
            },
            nl: {
                gameOver: 'Game Over',
                victory: 'Overwinnings!',
                paused: 'Gepauzeerd',
                finalTime: 'Eindtijd:',
                playAgain: 'Opnieuw spelen',
                changeLanguage: 'Taal wijzigen',
                resume: 'Hervatten',
                restart: 'Herstarten',
                previewTitle: 'Afvaltypen Gids',
                previewSubtitle: 'Leer de afvalcategorie√´n voordat je begint!',
                startGame: 'Start Spel',
                skip: 'Overslaan',
                selectLanguage: 'Selecteer Taal',
                singlePlayer: 'Een Speler',
                multiplayer: 'Multiplayer',
                backToLanguage: '‚Üê Terug naar Taal',
                gameOverTitle: 'Game Over',
                victoryTitle: 'Overwinnings!',
                pauseTitle: 'Gepauzeerd',
                gameOverRestartBtn: 'Opnieuw Spelen',
                gameOverChangeBtn: 'Taal Wijzigen',
                victoryRestartBtn: 'Opnieuw Spelen',
                victoryChangeBtn: 'Taal Wijzigen',
                enterNickname: 'Voer je bijnaam in',
                submit: 'Verzenden',
                leaderboard: 'Scorebord',
                continue: 'Doorgaan',
                gameInstructions: 'Klik op twee aangrenzende emojis om ze te verwisselen. Match 3+ van hetzelfde type om ze te verwijderen! Verwijder al het afval om te winnen!',
                newGame: 'Nieuw Spel',
                hint: 'Hint',
                time: 'Tijd',
                moves: 'Zetten',
                matches: 'Matches',
                gameMode: 'Kies Spelmodus',
                wasteType0: 'E-afval',
                wasteType1: 'Elektronica',
                wasteType2: 'Gemengde Items',
                wasteType3: 'Grote Apparaten',
                wasteType4: 'Gevaarlijk',
                wasteType5: 'Glas',
                wasteType6: 'Papier',
                wasteType7: 'Plastic/Metaal',
                wasteType8: 'Textiel',
                wasteType9: 'Organisch'
            },
            zh: {
                gameOver: 'Ê∏∏ÊàèÁªìÊùü',
                victory: 'ËÉúÂà©ÔºÅ',
                paused: 'Â∑≤ÊöÇÂÅú',
                finalTime: 'ÊúÄÁªàÊó∂Èó¥Ôºö',
                playAgain: 'ÂÜçÁé©‰∏ÄÊ¨°',
                changeLanguage: 'Êõ¥ÊîπËØ≠Ë®Ä',
                resume: 'ÁªßÁª≠',
                restart: 'ÈáçÊñ∞ÂºÄÂßã',
                previewTitle: 'ÂûÉÂúæÁ±ªÂûãÊåáÂçó',
                previewSubtitle: 'ÂºÄÂßãÂâç‰∫ÜËß£ÂûÉÂúæÂàÜÁ±ªÔºÅ',
                startGame: 'ÂºÄÂßãÊ∏∏Êàè',
                skip: 'Ë∑≥Ëøá',
                selectLanguage: 'ÈÄâÊã©ËØ≠Ë®Ä',
                singlePlayer: 'Âçï‰∫∫Ê∏∏Êàè',
                multiplayer: 'Â§ö‰∫∫Ê∏∏Êàè',
                backToLanguage: '‚Üê ËøîÂõûËØ≠Ë®ÄÈÄâÊã©',
                gameOverTitle: 'Ê∏∏ÊàèÁªìÊùü',
                victoryTitle: 'ËÉúÂà©ÔºÅ',
                pauseTitle: 'Â∑≤ÊöÇÂÅú',
                gameOverRestartBtn: 'ÂÜçÁé©‰∏ÄÊ¨°',
                gameOverChangeBtn: 'Êõ¥ÊîπËØ≠Ë®Ä',
                victoryRestartBtn: 'ÂÜçÁé©‰∏ÄÊ¨°',
                victoryChangeBtn: 'Êõ¥ÊîπËØ≠Ë®Ä',
                enterNickname: 'ËæìÂÖ•ÊÇ®ÁöÑÊòµÁß∞',
                submit: 'Êèê‰∫§',
                leaderboard: 'ÊéíË°åÊ¶ú',
                continue: 'ÁªßÁª≠',
                gameInstructions: 'ÁÇπÂáª‰∏§‰∏™Áõ∏ÈÇªÁöÑË°®ÊÉÖÁ¨¶Âè∑Êù•‰∫§Êç¢ÂÆÉ‰ª¨„ÄÇÂåπÈÖç3‰∏™ÊàñÊõ¥Â§öÁõ∏ÂêåÁ±ªÂûãÊù•Ê∏ÖÈô§ÂÆÉ‰ª¨ÔºÅÊ∏ÖÈô§ÊâÄÊúâÂûÉÂúæËé∑ËÉúÔºÅ',
                newGame: 'Êñ∞Ê∏∏Êàè',
                hint: 'ÊèêÁ§∫',
                time: 'Êó∂Èó¥',
                moves: 'Ê≠•Êï∞',
                matches: 'ÂåπÈÖç',
                gameMode: 'ÈÄâÊã©Ê∏∏ÊàèÊ®°Âºè',
                wasteType0: 'ÁîµÂ≠êÂûÉÂúæ',
                wasteType1: 'ÁîµÂ≠ê‰∫ßÂìÅ',
                wasteType2: 'Ê∑∑ÂêàÁâ©ÂìÅ',
                wasteType3: 'Â§ßÂûãÁîµÂô®',
                wasteType4: 'ÊúâÂÆ≥ÂûÉÂúæ',
                wasteType5: 'ÁéªÁíÉ',
                wasteType6: 'Á∫∏Âº†',
                wasteType7: 'Â°ëÊñô/ÈáëÂ±û',
                wasteType8: 'Á∫∫ÁªáÂìÅ',
                wasteType9: 'ÊúâÊú∫ÂûÉÂúæ'
            }
        };

        let currentLanguage = 'en';
        window.currentLanguage = currentLanguage;

        function t(key) {
            return translations[currentLanguage][key] || key;
        }

        // Waste emojis from shootwaste.html
        const wasteEmojis = [
            { emoji: 'üîã', name: 'Batteries', type: 4 },
            { emoji: 'üíª', name: 'Computer', type: 1 },
            { emoji: 'üîå', name: 'Electrical', type: 1 },
            { emoji: '‚åö', name: 'Watch', type: 2 },
            { emoji: 'üóÑÔ∏è', name: 'Refrigerator', type: 3 },
            { emoji: 'üì±', name: 'Mobile Phone', type: 1 },
            { emoji: 'üì°', name: 'Modem', type: 1 },
            { emoji: 'ü¶†', name: 'Virus Protection', type: 2 },
            { emoji: 'üõçÔ∏è', name: 'Big Bag', type: 2 },
            { emoji: 'üíø', name: 'CD/DVD', type: 2 },
            { emoji: 'üìº', name: 'Cassette', type: 2 },
            { emoji: 'üíæ', name: 'Diskette', type: 1 },
            { emoji: 'üéûÔ∏è', name: 'Photo Film', type: 2 },
            { emoji: 'üíâ', name: 'Needle', type: 4 },
            { emoji: 'üß≤', name: 'Magnet', type: 2 },
            { emoji: '‚ò¢Ô∏è', name: 'Radioactive', type: 4 },
            { emoji: 'üí°', name: 'Light Bulb', type: 2 },
            { emoji: 'üñºÔ∏è', name: 'Wallpaper', type: 3 },
            { emoji: 'ü™ë', name: 'Furniture', type: 3 },
            { emoji: 'üõèÔ∏è', name: 'Mattress', type: 3 },
            { emoji: 'üç≥', name: 'Pan', type: 3 },
            { emoji: 'üèΩ', name: 'Carpet', type: 3 },
            { emoji: 'üé™', name: 'Tent', type: 3 },
            { emoji: 'ü¶æ', name: 'Prosthesis', type: 2 },
            { emoji: 'üß±', name: 'Construction', type: 3 },
            { emoji: 'üíê', name: 'Floral Foam', type: 2 },
            { emoji: 'üå≤', name: 'Treated Wood', type: 3 },
            { emoji: 'üñºÔ∏è', name: 'Plastic Frame', type: 2 },
            { emoji: '‚úèÔ∏è', name: 'Stationery', type: 2 },
            { emoji: 'üè∫', name: 'Glass Vase', type: 5 },
            { emoji: 'üçæ', name: 'Glass Bottle', type: 5 },
            { emoji: 'üìú', name: 'Special Paper', type: 6 },
            { emoji: 'üìÅ', name: 'Binder', type: 2 },
            { emoji: 'üì¶', name: 'Cardboard', type: 6 },
            { emoji: 'üßÉ', name: 'Drink Carton', type: 7 },
            { emoji: 'ü•§', name: 'Cardboard Cup', type: 2 },
            { emoji: 'üß™', name: 'Chemical', type: 4 },
            { emoji: 'üé®', name: 'Paint', type: 4 },
            { emoji: 'üõ¢Ô∏è', name: 'Fuel/Oil', type: 4 },
            { emoji: 'üíä', name: 'Medicine', type: 4 },
            { emoji: 'üíÖ', name: 'Nail Polish', type: 2 },
            { emoji: 'üß¥', name: 'Aerosol Can', type: 7 },
            { emoji: 'ü•´', name: 'Metal Can', type: 7 },
            { emoji: 'üëë', name: 'Crown Cap', type: 7 },
            { emoji: 'üíº', name: 'Pouch', type: 2 },
            { emoji: 'üëï', name: 'Clothing', type: 8 },
            { emoji: 'üëü', name: 'Shoes', type: 8 },
            { emoji: 'üßµ', name: 'Textile', type: 8 },
            { emoji: 'üõçÔ∏è', name: 'Plastic Bag', type: 7 },
            { emoji: 'üçΩÔ∏è', name: 'Plastic Tray', type: 7 },
            { emoji: 'ü•£', name: 'Plastic Bowl', type: 7 },
            { emoji: 'üí≥', name: 'Plastic Card', type: 2 },
            { emoji: 'üç¥', name: 'Utensils', type: 2 },
            { emoji: 'üí©', name: 'Animal Waste', type: 2 },
            { emoji: 'üî™', name: 'Sharp Object', type: 2 },
            { emoji: 'üç∂', name: 'Crockery', type: 2 },
            { emoji: 'üïØÔ∏è', name: 'Candle Wax', type: 2 },
            { emoji: 'ü©π', name: 'Adhesive Tape', type: 2 },
            { emoji: 'üßÄ', name: 'Cheese Paper', type: 2 },
            { emoji: '‚òï', name: 'Coffee Cup', type: 2 },
            { emoji: 'üéâ', name: 'Fireworks', type: 2 },
            { emoji: 'üï∏Ô∏è', name: 'Fruit Net', type: 2 },
            { emoji: 'üå≥', name: 'Garden Waste', type: 9 },
            { emoji: 'üå±', name: 'Ground', type: 9 },
            { emoji: 'üåø', name: 'Plant Remains', type: 9 },
            { emoji: 'üõ†Ô∏è', name: 'Garden Tools', type: 3 },
            { emoji: 'ü•©', name: 'Meat/Fish', type: 9 },
            { emoji: 'üçî', name: 'Food Remains', type: 9 },
            { emoji: 'üç¶', name: 'Dairy', type: 9 },
            { emoji: 'üö≤', name: 'Bicycle', type: 3 }
        ];

        const BOARD_SIZE = 8;
        const TYPES_COUNT = 10;

        // Game state
        const gameState = {
            time: 0,
            gameOver: false,
            victory: false,
            paused: false
        };

        let board = [];
        let selectedGem = null;
        let gameTime = 0; // Time in seconds
        let gameStartTime = null; // When the game started
        let gameTimer = null; // Timer interval
        let moves = 0;
        let gameActive = true;
        let matchCount = 0;
        let hintsAvailable = 1; // Start with 1 hint available
        let suggestedMatch = null;

        // SQLite database
        let db = null;

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function startGameTimer() {
            gameStartTime = Date.now();
            gameTime = 0;

            if (gameTimer) {
                clearInterval(gameTimer);
            }

            gameTimer = setInterval(() => {
                if (gameActive && !gameState.paused) {
                    gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
                    document.getElementById('timeValue').textContent = formatTime(gameTime);
                }
            }, 1000);
        }

        function stopGameTimer() {
            if (gameTimer) {
                clearInterval(gameTimer);
                gameTimer = null;
            }
        }

        function initBoard() {
            board = [];
            let attempts = 0;
            const maxAttempts = 100;

            do {
                board = [];
                for (let row = 0; row < BOARD_SIZE; row++) {
                    board[row] = [];
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        board[row][col] = createRandomGem();
                    }
                }
                attempts++;
            } while ((findMatches().length > 0 || !hasValidMoves()) && attempts < maxAttempts);

            // If we couldn't generate a valid board in max attempts, create a guaranteed valid board
            if (attempts >= maxAttempts) {
                console.warn('Could not generate board with valid moves after', maxAttempts, 'attempts. Creating guaranteed valid board.');
                createGuaranteedValidBoard();
            }
        }

        function createRandomGem() {
            const randomIndex = Math.floor(Math.random() * wasteEmojis.length);
            return {
                emoji: wasteEmojis[randomIndex].emoji,
                type: wasteEmojis[randomIndex].type,
                name: wasteEmojis[randomIndex].name
            };
        }

        function renderBoard() {
            const gameBoard = document.getElementById('gameBoard');
            gameBoard.innerHTML = '';

            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const gemDiv = document.createElement('div');
                    gemDiv.id = `gem-${row}-${col}`;
                    gemDiv.dataset.row = row;
                    gemDiv.dataset.col = col;

                    if (board[row][col]) {
                        gemDiv.className = `gem waste-type-${board[row][col].type % 10}`;
                        gemDiv.setAttribute('data-type', board[row][col].type);
                        gemDiv.textContent = board[row][col].emoji;
                        gemDiv.title = board[row][col].name;
                    } else {
                        gemDiv.className = 'gem empty';
                    }

                    if (selectedGem && selectedGem.row === row && selectedGem.col === col) {
                        gemDiv.classList.add('selected');
                    }

                    gemDiv.onclick = () => selectGem(row, col);
                    gameBoard.appendChild(gemDiv);
                }
            }
        }

        function selectGem(row, col) {
            if (!gameActive) return;

            const gem = board[row][col];
            if (!gem) return;

            console.log('selectGem called:', {
                row, col,
                gem: `${gem.emoji} (type ${gem.type})`,
                selectedGem: selectedGem,
                gameActive: gameActive
            });

            if (!selectedGem) {
                console.log('No gem selected, selecting this gem');
                selectedGem = { row, col };
                renderBoard();
            } else {
                if (selectedGem.row === row && selectedGem.col === col) {
                    console.log('Same gem clicked, deselecting');
                    selectedGem = null;
                    renderBoard();
                    return;
                }

                const dx = Math.abs(selectedGem.row - row);
                const dy = Math.abs(selectedGem.col - col);
                const isAdjacent = (dx + dy === 1);

                console.log('Second gem clicked:', {
                    selectedPos: `${selectedGem.row},${selectedGem.col}`,
                    currentPos: `${row},${col}`,
                    dx: dx,
                    dy: dy,
                    distance: dx + dy,
                    isAdjacent: isAdjacent,
                    gem1: gem ? `${gem.emoji} (type ${gem.type})` : 'null'
                });

                if (isAdjacent) {
                    console.log('‚úì Gems are adjacent - performing swap');
                    const gem1 = board[selectedGem.row][selectedGem.col];
                    const gem2 = board[row][col];
                    console.log('Swapping:', `${gem1.emoji} (type ${gem1.type})`, 'with', `${gem2.emoji} (type ${gem2.type})`);
                    swapGems(selectedGem, { row, col });
                    moves++;
                    document.getElementById('movesValue').textContent = moves;
                    selectedGem = null;
                } else {
                    console.log('‚úó Gems are NOT adjacent (distance=' + (dx + dy) + ') - changing selection to new gem');
                    console.log('  To swap, gems must be directly next to each other (horizontally or vertically)');
                    selectedGem = { row, col };
                    renderBoard();
                }
            }
        }

        function swapGems(pos1, pos2) {
            const gem1 = board[pos1.row][pos1.col];
            const gem2 = board[pos2.row][pos2.col];

            console.log('Attempting swap:', {
                pos1: `${pos1.row},${pos1.col}`,
                pos2: `${pos2.row},${pos2.col}`,
                gem1: gem1 ? `${gem1.emoji} (type ${gem1.type})` : 'null',
                gem2: gem2 ? `${gem2.emoji} (type ${gem2.type})` : 'null'
            });

            const temp = board[pos1.row][pos1.col];
            board[pos1.row][pos1.col] = board[pos2.row][pos2.col];
            board[pos2.row][pos2.col] = temp;

            renderBoard();

            // Log the board state after swap for debugging
            console.log('Board state after swap:');
            for (let r = 0; r < BOARD_SIZE; r++) {
                let rowStr = '';
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c]) {
                        rowStr += board[r][c].emoji + ' ';
                    } else {
                        rowStr += '¬∑ ';
                    }
                }
                console.log('Row ' + r + ': ' + rowStr);
            }

            // Also log types for easier understanding
            console.log('Board types after swap:');
            for (let r = 0; r < BOARD_SIZE; r++) {
                let typeStr = '';
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c]) {
                        typeStr += board[r][c].type + ' ';
                    } else {
                        typeStr += '¬∑ ';
                    }
                }
                console.log('Row ' + r + ' types: ' + typeStr);
            }

            const matches = findMatches();
            console.log(`Swap result: ${matches.length} matches found`);
            if (matches.length > 0) {
                matches.forEach(match => {
                    const gem = board[match.row][match.col];
                    if (gem) {
                        console.log(`Match at ${match.row},${match.col}: ${gem.emoji} (type ${gem.type})`);
                    }
                });
            }

            if (matches.length > 0) {
                console.log('Matches found:', matches);
                setTimeout(() => {
                    clearMatches(matches);
                }, 300);
            } else {
                console.log('No matches - swapping back');
                console.log('Reason: This swap does not create a line of 3+ matching types');
                setTimeout(() => {
                    const temp = board[pos1.row][pos1.col];
                    board[pos1.row][pos1.col] = board[pos2.row][pos2.col];
                    board[pos2.row][pos2.col] = temp;
                    renderBoard();
                }, 300);
            }
        }

        function findMatches() {
            const matches = [];

            for (let row = 0; row < BOARD_SIZE; row++) {
                let count = 1;
                let currentType = board[row][0]?.type;

                for (let col = 1; col < BOARD_SIZE; col++) {
                    if (board[row][col] && board[row][col].type === currentType) {
                        count++;
                    } else {
                        if (count >= 3) {
                            for (let i = col - count; i < col; i++) {
                                matches.push({ row, col: i });
                            }
                        }
                        count = 1;
                        currentType = board[row][col]?.type;
                    }
                }
                if (count >= 3) {
                    for (let i = BOARD_SIZE - count; i < BOARD_SIZE; i++) {
                        matches.push({ row, col: i });
                    }
                }
            }

            for (let col = 0; col < BOARD_SIZE; col++) {
                let count = 1;
                let currentType = board[0][col]?.type;

                for (let row = 1; row < BOARD_SIZE; row++) {
                    if (board[row][col] && board[row][col].type === currentType) {
                        count++;
                    } else {
                        if (count >= 3) {
                            for (let i = row - count; i < row; i++) {
                                matches.push({ row: i, col });
                            }
                        }
                        count = 1;
                        currentType = board[row][col]?.type;
                    }
                }
                if (count >= 3) {
                    for (let i = BOARD_SIZE - count; i < BOARD_SIZE; i++) {
                        matches.push({ row: i, col });
                    }
                }
            }

            return matches;
        }

        // Helper function to count remaining gems on the board
        function countRemainingGems() {
            let count = 0;
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col]) {
                        count++;
                    }
                }
            }
            return count;
        }

        // Helper function to get all remaining gems as an array
        function getAllRemainingGems() {
            const gems = [];
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col]) {
                        gems.push(board[row][col]);
                    }
                }
            }
            return gems;
        }

        function clearMatches(matches) {
            if (matches.length === 0) {
                // No more matches - check if we need to regenerate or if game is over
                if (isBoardEmpty()) {
                    gameActive = false;
                    stopGameTimer();
                    // Game finished - directly prompt for nickname and show leaderboard
                    promptNicknameAndSave(gameTime);
                } else {
                    // Board still has gems but no matches
                    const gemCount = countRemainingGems();

                    // Rule 1: If less than 3 gems left, declare victory
                    if (gemCount < 3) {
                        console.log(`Only ${gemCount} gem(s) left - game complete!`);
                        gameActive = false;
                        stopGameTimer();
                        promptNicknameAndSave(gameTime);
                        return;
                    }

                    // Check if valid moves exist
                    if (!hasValidMoves()) {
                        // Rule 2: If 3 or more gems but no valid moves, regenerate with guaranteed matches
                        console.log(`${gemCount} gems left but no valid moves - regenerating with guaranteed matches`);
                        regenerateBoardWithGuaranteedMoves();
                    } else {
                        // Valid moves exist, game continues - no action needed
                    }
                }
                return;
            }

            matches.forEach(match => {
                const gemElement = document.getElementById(`gem-${match.row}-${match.col}`);
                if (gemElement) {
                    gemElement.classList.add('matched');
                }
            });

            matchCount++;
            document.getElementById('matchCountValue').textContent = matchCount;

            // Award extra hint every 3 matches
            if (matchCount % 3 === 0) {
                hintsAvailable++;
                updateHintButton();
            }

            setTimeout(() => {
                matches.forEach(match => {
                    board[match.row][match.col] = null;
                });

                applyGravity();
                setTimeout(() => {
                    const newMatches = findMatches();
                    if (newMatches.length > 0) {
                        clearMatches(newMatches);
                    } else {
                        // Continue checking after cascade
                        setTimeout(() => {
                            if (isBoardEmpty()) {
                                gameActive = false;
                                // Game finished - directly prompt for nickname and show leaderboard
                                promptNicknameAndSave(gameTime);
                            } else {
                                // Check for VICTORY: less than 3 gems left
                                const gemCount = countRemainingGems();
                                if (gemCount < 3) {
                                    console.log(`Only ${gemCount} gem(s) left after cascade - game complete!`);
                                    gameActive = false;
                                    promptNicknameAndSave(gameTime);
                                    return;
                                }

                                // Check if valid moves exist
                                if (!hasValidMoves()) {
                                    // No valid moves - regenerate board with guaranteed moves
                                    regenerateBoardWithGuaranteedMoves();
                                } else {
                                    // Valid moves exist, game continues - no action needed
                                }
                            }
                        }, 100);
                    }
                }, 500);
            }, 500);
        }

        function applyGravity() {
            for (let col = 0; col < BOARD_SIZE; col++) {
                const gems = [];
                for (let row = BOARD_SIZE - 1; row >= 0; row--) {
                    if (board[row][col]) {
                        gems.push(board[row][col]);
                    }
                }

                for (let row = BOARD_SIZE - 1; row >= 0; row--) {
                    if (gems.length > 0) {
                        board[row][col] = gems.shift();
                    } else {
                        // Leave empty - don't create new random gems
                        board[row][col] = null;
                    }
                }
            }
            renderBoard();

            const gems = document.querySelectorAll('.gem');
            gems.forEach(gem => {
                gem.classList.add('falling');
                setTimeout(() => gem.classList.remove('falling'), 500);
            });
        }

        function isBoardEmpty() {
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col]) {
                        return false;
                    }
                }
            }
            return true;
        }

        // Check if there are any valid moves that can create a match
        function hasValidMoves() {
            const validSwaps = [];
            // Try swapping adjacent gems to see if any match can be created
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    // Skip if current position is empty
                    if (!board[row][col]) continue;

                    // Check right neighbor
                    if (col < BOARD_SIZE - 1 && board[row][col + 1]) {
                        swapGemsTest(row, col, row, col + 1);
                        const matches = findMatches();
                        if (matches.length > 0) {
                            validSwaps.push({
                                pos1: { row, col },
                                pos2: { row, col: col + 1 },
                                matchCount: matches.length
                            });
                        }
                        swapGemsTest(row, col, row, col + 1); // Swap back
                    }
                    // Check bottom neighbor
                    if (row < BOARD_SIZE - 1 && board[row + 1][col]) {
                        swapGemsTest(row, col, row + 1, col);
                        const matches = findMatches();
                        if (matches.length > 0) {
                            validSwaps.push({
                                pos1: { row, col },
                                pos2: { row: row + 1, col },
                                matchCount: matches.length
                            });
                        }
                        swapGemsTest(row, col, row + 1, col); // Swap back
                    }
                }
            }

            if (validSwaps.length > 0) {
                console.log(`hasValidMoves: Found ${validSwaps.length} valid swaps:`, validSwaps.slice(0, 5));
                return true;
            }
            return false;
        }

        // Test swap without animation
        function swapGemsTest(row1, col1, row2, col2) {
            // Only swap if both positions have gems
            if (!board[row1][col1] || !board[row2][col2]) return;
            const temp = board[row1][col1];
            board[row1][col1] = board[row2][col2];
            board[row2][col2] = temp;
        }

        // Regenerate board by re-arranging remaining waste items
        function regenerateBoard() {
            console.log('Re-arranging remaining waste - no valid moves available');

            // Collect all existing non-null gems from the current board
            const existingGems = [];
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col]) {
                        existingGems.push(board[row][col]);
                    }
                }
            }

            // If no gems left, the game should have ended
            if (existingGems.length === 0) {
                console.log('No gems left to rearrange - game should be over');
                return;
            }

            // Use the new simplified logic
            regenerateBoardWithGuaranteedMoves();
        }

        // Regenerate board with guaranteed valid moves
        function regenerateBoardWithGuaranteedMoves() {
            console.log('Re-arranging remaining waste with guaranteed moves - no valid moves available');

            // Collect all existing non-null gems from the current board
            const existingGems = [];
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (board[row][col]) {
                        existingGems.push(board[row][col]);
                    }
                }
            }

            // If no gems left, the game should have ended
            if (existingGems.length === 0) {
                console.log('No gems left to rearrange - game should be over');
                return;
            }

            // Check if we have very few gems (‚â§4) that might be unwinnable
            if (existingGems.length <= 4) {
                console.log(`Only ${existingGems.length} gems left - checking if winnable...`);

                // Count types to see if we can form a match
                const typeCount = {};
                existingGems.forEach(gem => {
                    typeCount[gem.type] = (typeCount[gem.type] || 0) + 1;
                });
                const maxCount = Math.max(...Object.values(typeCount));
                const typeCountNum = Object.keys(typeCount).length;
                const hasDuplicateTypes = typeCountNum > 1;

                // VICTORY: If we have exactly 4 different types (1 of each),
                // it's impossible to match them all, so this is a victory
                if (existingGems.length === 4 && typeCountNum === 4 && maxCount === 1) {
                    console.log('All 4 remaining gems are of different types - game complete!');
                    gameActive = false;
                    promptNicknameAndSave(score);
                    return;
                }

                // VICTORY: If we have 3 different types (1 of each),
                // it's impossible to match them all, so this is a victory
                if (existingGems.length === 3 && typeCountNum === 3 && maxCount === 1) {
                    console.log('All 3 remaining gems are of different types - game complete!');
                    gameActive = false;
                    promptNicknameAndSave(score);
                    return;
                }

                // VICTORY: If we have 2 gems and they're different types
                if (existingGems.length === 2 && typeCountNum === 2) {
                    console.log('Only 2 gems left of different types - game complete!');
                    gameActive = false;
                    promptNicknameAndSave(score);
                    return;
                }

                // VICTORY: If we have 2 types with 2 gems each (e.g., A A B B),
                // it's impossible to clear all gems, so this is a victory
                if (existingGems.length === 4 && typeCountNum === 2) {
                    const counts = Object.values(typeCount);
                    if (counts.length === 2 && counts[0] === 2 && counts[1] === 2) {
                        console.log('Remaining gems are 2 of each type (A A B B) - game complete!');
                        gameActive = false;
                        promptNicknameAndSave(score);
                        return;
                    }
                }

                // GAME OVER: If we have gems that could potentially match but don't
                if (maxCount < 3 && hasDuplicateTypes) {
                    // Unwinnable: We have ‚â§4 gems but not 3+ of the same type
                    console.log(`Unwinnable state detected with ${existingGems.length} gems:`, existingGems.map(g => g.emoji).join(' '));
                    console.log('Type distribution:', typeCount);
                    gameActive = false;
                    // Show game over message
                    setTimeout(() => {
                        console.log('Game Over - Unwinnable state. Prompting for score save.');
                        promptNicknameAndSave(score);
                    }, 300);
                    return;
                }
            }

            // Clear the board
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    board[row][col] = null;
                }
            }

            // Group gems by type to ensure we have variety
            const gemsByType = {};
            existingGems.forEach(gem => {
                if (!gemsByType[gem.type]) {
                    gemsByType[gem.type] = [];
                }
                gemsByType[gem.type].push(gem);
            });

            // Check if we have at least 2 gems of the same type
            const validTypes = Object.keys(gemsByType).filter(type => gemsByType[type].length >= 2);
            const hasValidPairs = validTypes.length > 0;

            // Place gems strategically to ensure valid moves exist
            const placedPositions = new Set();
            let guaranteedMoveCreated = false;
            let usedGems = []; // Store used gems for filtering

            // If we have at least 2 gems of the same type, create a guaranteed move
            if (hasValidPairs && existingGems.length >= 3) {
                // Pick a random valid type
                const chosenType = validTypes[Math.floor(Math.random() * validTypes.length)];
                const availableGemsOfType = gemsByType[chosenType];

                // Pick 2 gems of the same type for our guaranteed pattern
                const gem1 = availableGemsOfType[0];
                const gem2 = availableGemsOfType[1];

                // Pick a random different type for the middle gem
                const otherTypes = Object.keys(gemsByType).filter(type => type !== chosenType);
                const otherType = otherTypes[Math.floor(Math.random() * otherTypes.length)];
                const middleGem = gemsByType[otherType][0];

                // Choose horizontal or vertical placement
                const useHorizontal = Math.random() < 0.5;
                let row, col, positions;

                if (useHorizontal) {
                    row = Math.floor(Math.random() * BOARD_SIZE);
                    col = Math.floor(Math.random() * (BOARD_SIZE - 2));
                    positions = [`${row}-${col}`, `${row}-${col + 1}`, `${row}-${col + 2}`];
                } else {
                    col = Math.floor(Math.random() * BOARD_SIZE);
                    row = Math.floor(Math.random() * (BOARD_SIZE - 2));
                    positions = [`${row}-${col}`, `${row + 1}-${col}`, `${row + 2}-${col}`];
                }

                // Place the pattern: X Y X (swapping Y with X creates XXX)
                board[parseInt(positions[0].split('-')[0])][parseInt(positions[0].split('-')[1])] = {
                    emoji: gem1.emoji,
                    type: gem1.type,
                    name: gem1.name
                };
                placedPositions.add(positions[0]);

                board[parseInt(positions[1].split('-')[0])][parseInt(positions[1].split('-')[1])] = {
                    emoji: middleGem.emoji,
                    type: middleGem.type,
                    name: middleGem.name
                };
                placedPositions.add(positions[1]);

                board[parseInt(positions[2].split('-')[0])][parseInt(positions[2].split('-')[1])] = {
                    emoji: gem2.emoji,
                    type: gem2.type,
                    name: gem2.name
                };
                placedPositions.add(positions[2]);

                guaranteedMoveCreated = true;
                console.log(`Created guaranteed move with type ${chosenType} at positions`, positions);

                // Store the used gems for later filtering
                usedGems = [gem1, gem2, middleGem];
            }

            // Collect all remaining gems (excluding the 3 we just placed if we created a guaranteed move)
            const remainingGems = existingGems.filter(gem => {
                if (guaranteedMoveCreated) {
                    // Check if this gem was one of the 3 we used
                    // Use a simple check based on emoji and type
                    return !usedGems.some(usedGem =>
                        usedGem.emoji === gem.emoji && usedGem.type === gem.type
                    );
                }
                return true;
            });

            // Clear all positions except the guaranteed move positions
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const pos = `${r}-${c}`;
                    if (!placedPositions.has(pos)) {
                        board[r][c] = null;
                    }
                }
            }

            // COMPACT PLACEMENT: Place remaining gems in a compact area
            // Calculate optimal area to fit all gems with minimal empty space
            const numGems = remainingGems.length;
            const colsNeeded = Math.ceil(Math.sqrt(numGems));
            const rowsNeeded = Math.ceil(numGems / colsNeeded);

            // Start from bottom-left to leave room for gravity effects
            const startRow = BOARD_SIZE - rowsNeeded;
            const startCol = 0;

            // Shuffle remaining gems for variety
            const shuffledGems = [...remainingGems];
            for (let i = shuffledGems.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledGems[i], shuffledGems[j]] = [shuffledGems[j], shuffledGems[i]];
            }

            // Place gems compactly in a rectangle
            for (let i = 0; i < shuffledGems.length; i++) {
                const gem = shuffledGems[i];
                const row = startRow + Math.floor(i / colsNeeded);
                const col = startCol + (i % colsNeeded);

                // Safety check
                if (row < BOARD_SIZE && col < BOARD_SIZE) {
                    board[row][col] = gem;
                }
            }

            // If we have many empty positions, try to move gems closer together
            // This is especially important when there are < 20 gems
            if (remainingGems.length < 20) {
                const allPositions = [];
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[r][c] && !placedPositions.has(`${r}-${c}`)) {
                            allPositions.push({ r, c });
                        }
                    }
                }

                // If gems are too spread out, compact them more
                const spreadThreshold = remainingGems.length * 1.5;
                if (allPositions.length > spreadThreshold) {
                    console.log(`Compacting ${remainingGems.length} gems from ${allPositions.length} positions`);

                    // Gather all gems
                    const gemsToMove = allPositions.map(pos => board[pos.r][pos.c]);
                    for (const pos of allPositions) {
                        board[pos.r][pos.c] = null;
                    }

                    // Re-place in even more compact arrangement (triangular packing)
                    const compactRows = Math.ceil(Math.sqrt(remainingGems.length));
                    for (let i = 0; i < gemsToMove.length; i++) {
                        const gem = gemsToMove[i];
                        // More compact triangular arrangement
                        const row = startRow + Math.floor(i / (colsNeeded - 1));
                        const col = startCol + (i % (colsNeeded - 1));

                        if (row < BOARD_SIZE && col < BOARD_SIZE && board[row][col] === null) {
                            board[row][col] = gem;
                        } else {
                            // Find first available spot
                            for (let r = startRow; r < BOARD_SIZE; r++) {
                                for (let c = 0; c < BOARD_SIZE; c++) {
                                    if (board[r][c] === null) {
                                        board[r][c] = gem;
                                        r = BOARD_SIZE; // Break outer loop
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Verify that we have valid moves and NO pre-existing matches
            let existingMatches = findMatches();
            let validMovesCheck = hasValidMoves();

            if (existingMatches.length > 0) {
                console.warn('WARNING: Pre-existing matches found after regeneration! Re-arranging...');
                console.log('Pre-existing matches:', existingMatches.length);
            }

            if (existingMatches.length > 0 || !validMovesCheck) {
                if (existingMatches.length > 0) {
                    console.log('Board state with pre-existing matches:', board.map(row => row.map(cell => cell ? cell.emoji : '¬∑').join(' ')).join('\n'));
                } else {
                    console.warn('WARNING: No valid moves found after regeneration attempt. This should not happen!');
                    console.log('Board state:', board.map(row => row.map(cell => cell ? cell.emoji : '¬∑').join(' ')).join('\n'));
                }

                // Check if it's mathematically impossible to create valid moves
                // Count gems by type
                const typeCount = {};
                let totalGems = 0;
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[r][c] && !placedPositions.has(`${r}-${c}`)) {
                            const type = board[r][c].type;
                            typeCount[type] = (typeCount[type] || 0) + 1;
                            totalGems++;
                        }
                    }
                }

                // If no type has at least 3 gems, it's impossible to create any match
                const maxOfAnyType = Math.max(...Object.values(typeCount));
                if (maxOfAnyType < 3) {
                    console.log(`Victory condition: Only ${totalGems} gems left and no type has 3+ (max is ${maxOfAnyType})`);
                    console.log('Type counts:', typeCount);
                    gameActive = false;
                    stopGameTimer();
                    promptNicknameAndSave(gameTime);
                    return;
                }

                // Try different COMPACT arrangement strategies
                const allGems = [];
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (board[r][c] && !placedPositions.has(`${r}-${c}`)) {
                            allGems.push(board[r][c]);
                        }
                        board[r][c] = null; // Clear for fresh placement
                    }
                }

                let arrangementTried = 0;
                const maxArrangements = 100; // Increased attempts for compact placement
                let foundValidBoard = false;

                // For small numbers of gems (<=6), use more aggressive clustering
                const gemCount = allGems.length;
                const isSmallCount = gemCount <= 6;

                // Strategy 1: Try compact placement in different areas
                while ((findMatches().length > 0 || !hasValidMoves()) && arrangementTried < maxArrangements && !foundValidBoard) {
                    arrangementTried++;

                    // Clear board except guaranteed move
                    for (let r = 0; r < BOARD_SIZE; r++) {
                        for (let c = 0; c < BOARD_SIZE; c++) {
                            const pos = `${r}-${c}`;
                            if (!placedPositions.has(pos)) {
                                board[r][c] = null;
                            }
                        }
                    }

                    // For small counts, start from bottom-left corner always for consistency
                    const anchorRow = isSmallCount ? BOARD_SIZE - 2 : Math.floor(Math.random() * (BOARD_SIZE - 2));
                    const anchorCol = isSmallCount ? 0 : Math.floor(Math.random() * (BOARD_SIZE - 2));

                    // Shuffle gems
                    const shuffled = [...allGems];
                    for (let i = shuffled.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                    }

                    // For small gem counts, group by type first to ensure clustering
                    if (isSmallCount) {
                        // Group gems by type
                        const gemsByType = {};
                        shuffled.forEach(gem => {
                            if (!gemsByType[gem.type]) {
                                gemsByType[gem.type] = [];
                            }
                            gemsByType[gem.type].push(gem);
                        });

                        // Place types in alternating pattern to enable matches
                        let row = anchorRow;
                        let col = anchorCol;
                        const types = Object.keys(gemsByType);
                        let typeIndex = 0;

                        // For each type, place all gems of that type
                        types.forEach(type => {
                            const gemsOfType = gemsByType[type];
                            gemsOfType.forEach(gem => {
                                if (col >= BOARD_SIZE) {
                                    row--;
                                    col = 0;
                                }
                                if (row >= 0) {
                                    board[row][col] = gem;
                                    col++;
                                }
                            });
                            typeIndex++;
                        });
                    } else {
                        // Original placement for larger counts
                        // Place in compact rectangle near anchor
                        const colsNeeded = Math.ceil(Math.sqrt(shuffled.length));
                        for (let i = 0; i < shuffled.length; i++) {
                            const row = anchorRow + Math.floor(i / colsNeeded);
                            const col = anchorCol + (i % colsNeeded);
                            if (row < BOARD_SIZE && col < BOARD_SIZE) {
                                board[row][col] = shuffled[i];
                            }
                        }
                    }

                    // Check if this arrangement works
                    if (findMatches().length === 0 && hasValidMoves()) {
                        foundValidBoard = true;
                        console.log(`SUCCESS: Found valid compact arrangement at attempt ${arrangementTried}`);
                    }
                }

                // Strategy 2: Try spiral compaction
                if (!foundValidBoard && arrangementTried < maxArrangements) {
                    const centerR = Math.floor(BOARD_SIZE / 2);
                    const centerC = Math.floor(BOARD_SIZE / 2);

                    // Clear board
                    for (let r = 0; r < BOARD_SIZE; r++) {
                        for (let c = 0; c < BOARD_SIZE; c++) {
                            const pos = `${r}-${c}`;
                            if (!placedPositions.has(pos)) {
                                board[r][c] = null;
                            }
                        }
                    }

                    // Create spiral positions
                    const spiralPositions = [];
                    let top = 0, bottom = BOARD_SIZE - 1, left = 0, right = BOARD_SIZE - 1;

                    while (top <= bottom && left <= right) {
                        for (let c = left; c <= right; c++) spiralPositions.push({ r: top, c });
                        top++;
                        for (let r = top; r <= bottom; r++) spiralPositions.push({ r, c: right });
                        right--;
                        if (top <= bottom) {
                            for (let c = right; c >= left; c--) spiralPositions.push({ r: bottom, c });
                            bottom--;
                        }
                        if (left <= right) {
                            for (let r = bottom; r >= top; r--) spiralPositions.push({ r, c: left });
                            left++;
                        }
                    }

                    // Place gems in spiral order
                    const shuffled = [...allGems];
                    for (let i = shuffled.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                    }

                    let placed = 0;
                    for (let i = 0; i < spiralPositions.length && placed < shuffled.length; i++) {
                        const pos = spiralPositions[i];
                        const posKey = `${pos.r}-${pos.c}`;
                        if (!placedPositions.has(posKey)) {
                            board[pos.r][pos.c] = shuffled[placed];
                            placed++;
                        }
                    }

                    if (findMatches().length === 0 && hasValidMoves()) {
                        foundValidBoard = true;
                        console.log(`SUCCESS: Found valid spiral arrangement at attempt ${arrangementTried}`);
                    }
                }

                const finalMatches = findMatches();
                const finalValidMoves = hasValidMoves();

                if (finalMatches.length > 0) {
                    console.error(`FAILED: Still have ${finalMatches.length} pre-existing matches after ${arrangementTried} attempts!`);
                } else if (!finalValidMoves) {
                    console.error(`FAILED: No valid moves after ${arrangementTried} compact arrangement attempts!`);
                    console.log('This board configuration may truly have no valid moves.');

                    // Final check: Is it mathematically impossible?
                    const typeCount = {};
                    let totalGems = 0;
                    for (let r = 0; r < BOARD_SIZE; r++) {
                        for (let c = 0; c < BOARD_SIZE; c++) {
                            if (board[r][c]) {
                                const type = board[r][c].type;
                                typeCount[type] = (typeCount[type] || 0) + 1;
                                totalGems++;
                            }
                        }
                    }

                    const maxOfAnyType = Math.max(...Object.values(typeCount));
                    if (maxOfAnyType < 3) {
                        console.log(`Declaring victory: ${totalGems} gems remaining, no type has 3+ gems (max: ${maxOfAnyType})`);
                        console.log('Type distribution:', typeCount);
                        gameActive = false;
                        stopGameTimer();
                        promptNicknameAndSave(gameTime);
                        return;
                    }
                } else {
                    console.log(`SUCCESS: Found valid board with no pre-existing matches after ${arrangementTried} attempts`);
                }
            } else {
                console.log('Valid moves confirmed, no pre-existing matches - board is good!');
            }

            renderBoard();

            // Show message to user
            const hintDiv = document.getElementById('hint');
            hintDiv.textContent = 'Waste re-arranged! Try finding new matches.';
            setTimeout(() => {
                hintDiv.textContent = 'Click two adjacent emojis to swap them. Match 3+ of the same type to clear them! Clear all waste to win!';
            }, 3000);
        }

        // Create a board that is guaranteed to have at least one valid move
        function createGuaranteedValidBoard() {
            // Clear board
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    board[row][col] = null;
                }
            }

            // Fill board with random gems first
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    board[row][col] = createRandomGem();
                }
            }

            // Create 2-3 guaranteed swap patterns that will create matches when swapped
            // Pattern: X Y X - swapping Y with a matching X creates XXX
            const numMoves = 2 + Math.floor(Math.random() * 2); // 2-3 moves
            const usedPositions = new Set();

            for (let m = 0; m < numMoves; m++) {
                let attempts = 0;
                let placed = false;

                while (!placed && attempts < 50) {
                    attempts++;

                    // Try horizontal swap pattern
                    if (Math.random() < 0.5) {
                        const row = Math.floor(Math.random() * BOARD_SIZE);
                        const col = Math.floor(Math.random() * (BOARD_SIZE - 2));

                        // We'll place X Y X pattern (positions col, col+1, col+2)
                        // Where Y is different from X
                        const pos1 = `${row}-${col}`;
                        const pos2 = `${row}-${col + 1}`;
                        const pos3 = `${row}-${col + 2}`;

                        // Check if positions are free
                        let canPlace = true;
                        for (const pos of [pos1, pos2, pos3]) {
                            if (usedPositions.has(pos)) {
                                canPlace = false;
                                break;
                            }
                        }

                        if (canPlace) {
                            const typeX = Math.floor(Math.random() * TYPES_COUNT);
                            const typeY = Math.floor(Math.random() * TYPES_COUNT);
                            // Make sure Y is different from X
                            const finalTypeY = typeY === typeX ? (typeY + 1) % TYPES_COUNT : typeY;

                            const availableGemsX = wasteEmojis.filter(w => w.type === typeX);
                            const availableGemsY = wasteEmojis.filter(w => w.type === finalTypeY);

                            // Safety check: ensure we have gems of both types
                            if (availableGemsX.length === 0 || availableGemsY.length === 0) {
                                continue; // Skip this attempt if no gems available for these types
                            }

                            // Place X at position 0
                            const gem1 = availableGemsX[Math.floor(Math.random() * availableGemsX.length)];
                            board[row][col] = {
                                emoji: gem1.emoji,
                                type: typeX,
                                name: gem1.name
                            };
                            usedPositions.add(pos1);

                            // Place Y at position 1
                            const gem2 = availableGemsY[Math.floor(Math.random() * availableGemsY.length)];
                            board[row][col + 1] = {
                                emoji: gem2.emoji,
                                type: finalTypeY,
                                name: gem2.name
                            };
                            usedPositions.add(pos2);

                            // Place X at position 2
                            const gem3 = availableGemsX[Math.floor(Math.random() * availableGemsX.length)];
                            board[row][col + 2] = {
                                emoji: gem3.emoji,
                                type: typeX,
                                name: gem3.name
                            };
                            usedPositions.add(pos3);

                            placed = true;
                        }
                    } else {
                        // Try vertical swap pattern
                        const row = Math.floor(Math.random() * (BOARD_SIZE - 2));
                        const col = Math.floor(Math.random() * BOARD_SIZE);

                        // We'll place X Y X pattern vertically (rows row, row+1, row+2)
                        const pos1 = `${row}-${col}`;
                        const pos2 = `${row + 1}-${col}`;
                        const pos3 = `${row + 2}-${col}`;

                        // Check if positions are free
                        let canPlace = true;
                        for (let i = 0; i < 3; i++) {
                            const pos = `${row + i}-${col}`;
                            if (usedPositions.has(pos)) {
                                canPlace = false;
                                break;
                            }
                        }

                        if (canPlace) {
                            const typeX = Math.floor(Math.random() * TYPES_COUNT);
                            const typeY = Math.floor(Math.random() * TYPES_COUNT);
                            // Make sure Y is different from X
                            const finalTypeY = typeY === typeX ? (typeY + 1) % TYPES_COUNT : typeY;

                            const availableGemsX = wasteEmojis.filter(w => w.type === typeX);
                            const availableGemsY = wasteEmojis.filter(w => w.type === finalTypeY);

                            // Safety check: ensure we have gems of both types
                            if (availableGemsX.length === 0 || availableGemsY.length === 0) {
                                continue; // Skip this attempt if no gems available for these types
                            }

                            // Place X at position 0
                            const gem1 = availableGemsX[Math.floor(Math.random() * availableGemsX.length)];
                            board[row][col] = {
                                emoji: gem1.emoji,
                                type: typeX,
                                name: gem1.name
                            };
                            usedPositions.add(pos1);

                            // Place Y at position 1
                            const gem2 = availableGemsY[Math.floor(Math.random() * availableGemsY.length)];
                            board[row + 1][col] = {
                                emoji: gem2.emoji,
                                type: finalTypeY,
                                name: gem2.name
                            };
                            usedPositions.add(pos2);

                            // Place X at position 2
                            const gem3 = availableGemsX[Math.floor(Math.random() * availableGemsX.length)];
                            board[row + 2][col] = {
                                emoji: gem3.emoji,
                                type: typeX,
                                name: gem3.name
                            };
                            usedPositions.add(pos3);

                            placed = true;
                        }
                    }
                }
            }

            console.log('Created board with', numMoves, 'guaranteed swap moves (X Y X pattern)');
        }

        function newGame() {
            gameTime = 0;
            moves = 0;
            matchCount = 0;
            hintsAvailable = 1; // Start with 1 hint available
            suggestedMatch = null;
            gameActive = false; // Start as inactive until preview is dismissed
            selectedGem = null;

            stopGameTimer(); // Stop any existing timer

            document.getElementById('timeValue').textContent = '00:00';
            document.getElementById('movesValue').textContent = '0';
            document.getElementById('matchCountValue').textContent = '0';

            console.log('New game initialized:', { hintsAvailable, gameActive });

            // Initialize hint button
            updateHintButton();

            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('victory').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'none'; // Hide game board on restart

            initBoard();
            renderBoard();
            showLanguageSelect();
        }

        // Language selection
        function selectLanguage(lang) {
            currentLanguage = lang;
            window.currentLanguage = lang;

            // Update UI text
            updateUIText();

            // Show waste type guide instead of game mode selection (single player only)
            document.getElementById('languageSelect').style.display = 'none';
            document.getElementById('wasteTypePreview').style.display = 'block';

            // Populate waste type guide
            populateWasteTypeGuide();
        }

        function showLanguageSelect() {
            document.getElementById('gameModeSelect').style.display = 'none';
            document.getElementById('languageSelect').style.display = 'block';
        }

        function startSinglePlayer() {
            // Start single player game - the waste type guide is already shown in game mode selection
            startGameFromPreview();
        }

        function updateUIText() {
            // Update UI elements with current language
            document.getElementById('previewTitle').textContent = t('previewTitle');
            document.getElementById('previewSubtitle').textContent = t('previewSubtitle');
            document.getElementById('startGameBtn').textContent = t('startGame');
            document.getElementById('skipBtn').textContent = t('skip');
            document.getElementById('gameOverTitle').textContent = t('gameOverTitle');
            document.getElementById('victoryTitle').textContent = t('victoryTitle');
            document.getElementById('pauseTitle').textContent = t('pauseTitle');
            document.getElementById('gameOverRestartBtn').textContent = t('gameOverRestartBtn');
            document.getElementById('gameOverChangeBtn').textContent = t('gameOverChangeBtn');
            document.getElementById('victoryRestartBtn').textContent = t('victoryRestartBtn');
            document.getElementById('victoryChangeBtn').textContent = t('victoryChangeBtn');

            // Update dynamic text
            const gameInfo = document.getElementById('gameInfo');
            if (gameInfo) {
                gameInfo.children[0].innerHTML = `${t('time')}: <span id="timeValue">${document.getElementById('timeValue').textContent}</span>`;
                gameInfo.children[1].innerHTML = `${t('moves')}: <span id="movesValue">${document.getElementById('movesValue').textContent}</span>`;
                gameInfo.children[2].innerHTML = `${t('matches')}: <span id="matchCountValue">${document.getElementById('matchCountValue').textContent}</span>`;
            }

            const hint = document.getElementById('hint');
            if (hint) {
                hint.textContent = t('gameInstructions');
            }

            const newGameBtn = document.querySelector('#controls button:first-child');
            if (newGameBtn) {
                newGameBtn.textContent = t('newGame');
            }

            const hintBtn = document.getElementById('hintBtn');
            if (hintBtn) {
                hintBtn.textContent = `${t('hint')} (${hintsAvailable})`;
            }
        }

        function showMainMenu() {
            // Reset to main menu (single player - show waste type preview)
            document.getElementById('multiplayerLobby').style.display = 'none';
            document.getElementById('wasteTypePreview').style.display = 'block';

            // Populate waste type guide
            populateWasteTypeGuide();
        }

        function startGameFromPreview() {
            // Hide the waste type preview
            document.getElementById('wasteTypePreview').style.display = 'none';

            // Show and activate the game
            document.getElementById('gameContainer').style.display = 'block';
            gameActive = true;

            // Start the game timer
            startGameTimer();

            console.log('Game started from preview');
        }

        function showMultiplayerLobby() {
            // For now, just show coming soon message
            alert('Multiplayer mode coming soon!');
            showMainMenu();
        }

        function togglePause() {
            if (gameState.gameOver || gameState.victory) return;
            gameState.paused = !gameState.paused;
            document.getElementById('pauseMenu').style.display = gameState.paused ? 'block' : 'none';
        }

        // Find potential swap moves that would create matches
        function findSwapHints() {
            const swapMoves = [];
            let checkedPositions = 0;
            let emptyPositions = 0;

            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    checkedPositions++;

                    // Skip if current position is empty
                    if (!board[row][col]) {
                        emptyPositions++;
                        continue;
                    }

                    // Check right neighbor
                    if (col < BOARD_SIZE - 1 && board[row][col + 1]) {
                        swapGemsTest(row, col, row, col + 1);
                        const matches = findMatches();
                        swapGemsTest(row, col, row, col + 1); // Swap back

                        if (matches.length > 0) {
                            swapMoves.push({
                                pos1: { row, col },
                                pos2: { row: row, col: col + 1 },
                                matches: matches
                            });
                        }
                    }

                    // Check bottom neighbor
                    if (row < BOARD_SIZE - 1 && board[row + 1][col]) {
                        swapGemsTest(row, col, row + 1, col);
                        const matches = findMatches();
                        swapGemsTest(row, col, row + 1, col); // Swap back

                        if (matches.length > 0) {
                            swapMoves.push({
                                pos1: { row, col },
                                pos2: { row: row + 1, col: col },
                                matches: matches
                            });
                        }
                    }
                }
            }

            console.log('findSwapHints result:', {
                checkedPositions,
                emptyPositions,
                validMovesFound: swapMoves.length
            });

            return swapMoves;
        }

        function showHint() {
            console.log('showHint called:', { gameActive, hintsAvailable });

            // Check if game is active
            if (!gameActive) {
                console.log('Hint failed: gameActive is', gameActive);
                alert('Hint is not available during the preview screen. Start the game first!');
                return;
            }

            // Check if hints are available
            if (hintsAvailable <= 0) {
                console.log('Hint failed: no hints available, hintsAvailable =', hintsAvailable);
                alert('No hints available! Earn more by matching groups of waste.');
                return;
            }

            const swapMoves = findSwapHints();
            console.log('Found swap moves:', swapMoves.length);

            if (swapMoves.length > 0) {
                // Pick a random valid swap move
                const randomMove = swapMoves[Math.floor(Math.random() * swapMoves.length)];
                console.log('Showing hint for move:', randomMove);

                // Highlight both gems that should be swapped
                const gemElement1 = document.getElementById(`gem-${randomMove.pos1.row}-${randomMove.pos1.col}`);
                const gemElement2 = document.getElementById(`gem-${randomMove.pos2.row}-${randomMove.pos2.col}`);

                if (gemElement1) {
                    gemElement1.style.animation = 'pulse 0.5s';
                    setTimeout(() => {
                        gemElement1.style.animation = '';
                    }, 500);
                } else {
                    console.warn('Could not find gem element 1:', `gem-${randomMove.pos1.row}-${randomMove.pos1.col}`);
                }

                if (gemElement2) {
                    gemElement2.style.animation = 'pulse 0.5s';
                    setTimeout(() => {
                        gemElement2.style.animation = '';
                    }, 500);
                } else {
                    console.warn('Could not find gem element 2:', `gem-${randomMove.pos2.row}-${randomMove.pos2.col}`);
                }

                // Use up a hint
                hintsAvailable--;
                updateHintButton();
                console.log('Hint used, remaining hints:', hintsAvailable);
            } else {
                // No valid swap moves found
                const gemCount = countRemainingGems();

                // Rule 1: If less than 3 gems left, declare victory
                if (gemCount < 3) {
                    console.log(`Only ${gemCount} gem(s) left - game complete!`);
                    gameActive = false;
                    promptNicknameAndSave(score);
                    return;
                }

                // Rule 2: If 3 or more gems but no valid moves, regenerate with guaranteed matches
                console.log('No valid swap moves found, regenerating board...');
                alert('No valid moves available! The board will be regenerated.');
                regenerateBoardWithGuaranteedMoves();
            }
        }

        function updateHintButton() {
            const hintBtn = document.getElementById('hintBtn');
            if (!hintBtn) {
                console.warn('Hint button not found in DOM');
                return;
            }

            hintBtn.textContent = `Hint (${hintsAvailable})`;

            // Update button state based on both game state and hint availability
            if (hintsAvailable <= 0 || !gameActive) {
                hintBtn.disabled = true;
            } else {
                hintBtn.disabled = false;
            }

            console.log('Hint button updated:', {
                hintsAvailable,
                gameActive,
                disabled: hintBtn.disabled
            });
        }

        // Populate waste type guide
        function populateWasteTypeGuide() {
            const grids = [
                document.getElementById('wasteTypeGrid'),
                document.getElementById('wasteTypeGridPreview')
            ];

            // Group waste by type
            const wasteByType = {};
            wasteEmojis.forEach(item => {
                if (!wasteByType[item.type]) {
                    wasteByType[item.type] = [];
                }
                wasteByType[item.type].push(item);
            });

            // Create waste type cards
            let html = '';
            const colorMap = {
                0: '#DC143C',
                1: '#FF6347',
                2: '#FFA500',
                3: '#00CED1',
                4: '#FF1493',
                5: '#00CED1',
                6: '#4169E1',
                7: '#FFA500',
                8: '#9370DB',
                9: '#8B4513'
            };

            Object.keys(wasteByType).forEach(type => {
                // Use translation for type name
                const typeName = t(`wasteType${type}`) || `Type ${type}`;
                const items = wasteByType[type];
                const bgColor = colorMap[type] || '#666666';

                // Create HTML for items with emoji and names
                let itemsHtml = '';
                items.forEach(item => {
                    itemsHtml += `<div style="display: inline-flex; flex-direction: column; align-items: center; margin: 5px; max-width: 70px;">
                        <span style="font-size: 24px;">${item.emoji}</span>
                        <span style="font-size: 9px; line-height: 1.2; margin-top: 2px; word-wrap: break-word; text-align: center;">${item.name}</span>
                    </div>`;
                });

                html += `
                    <div style="background: ${bgColor}; color: white; padding: 10px; border-radius: 8px; text-align: center;">
                        <div style="font-weight: bold; font-size: 16px; margin-bottom: 5px;">${typeName}</div>
                        <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 3px;">${itemsHtml}</div>
                        <div style="font-size: 12px; margin-top: 5px; opacity: 0.8;">${items.length} items</div>
                    </div>
                `;
            });

            // Populate all found grids
            grids.forEach(grid => {
                if (grid) {
                    grid.innerHTML = html;
                }
            });
        }

        // Start game from preview
        function startGameFromPreview() {
            console.log('startGameFromPreview called!');
            console.log('wasteTypePreview element:', document.getElementById('wasteTypePreview'));
            console.log('gameContainer element:', document.getElementById('gameContainer'));

            document.getElementById('wasteTypePreview').style.display = 'none';
            document.getElementById('gameModeSelect').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';
            gameActive = true;

            console.log('Game active set to:', gameActive);

            // Start the game timer
            startGameTimer();
            // Update hint button state
            updateHintButton();
            // Update UI text including instructions
            updateUIText();

            console.log('startGameFromPreview completed');
        }

        // Initialize SQLite database
        function initDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('MatchWasteDB', 2); // Incremented version from 1 to 2

                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    db = request.result;
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    const oldVersion = event.oldVersion;

                    // Version 1 to 2 upgrade: change from 'score' to 'time' index
                    if (oldVersion < 2) {
                        // Delete old object store if it exists
                        if (db.objectStoreNames.contains('scores')) {
                            db.deleteObjectStore('scores');
                        }
                        // Create new object store with 'time' index
                        const store = db.createObjectStore('scores', { keyPath: 'id', autoIncrement: true });
                        store.createIndex('time', 'time', { unique: false });
                    }
                };
            });
        }

        // Save time to SQLite
        async function saveScore() {
            const nickname = document.getElementById('nicknameInput').value.trim();
            if (!nickname) {
                alert('Please enter a nickname!');
                return;
            }

            const timeToSave = window.pendingTime || gameTime;

            try {
                await initDatabase();
                const transaction = db.transaction(['scores'], 'readwrite');
                const store = transaction.objectStore('scores');
                const scoreData = {
                    nickname: nickname,
                    time: timeToSave,
                    date: new Date().toISOString()
                };

                store.add(scoreData);

                transaction.oncomplete = async () => {
                    document.getElementById('nicknamePrompt').style.display = 'none';
                    // Load and display leaderboard
                    const topScores = await loadLeaderboard();
                    showLeaderboardTable(topScores, nickname, timeToSave);
                };

                transaction.onerror = () => {
                    console.error('Error saving score:', transaction.error);
                    alert('Error saving score!');
                };
            } catch (error) {
                console.error('Error initializing database:', error);
                alert('Error initializing database!');
            }
        }

        // Show leaderboard
        function showLeaderboard() {
            const transaction = db.transaction(['scores'], 'readonly');
            const store = transaction.objectStore('scores');
            const index = store.index('time');
            const direction = 'next'; // Changed from 'prev' - lower time is better
            const count = 10;

            const request = index.openCursor(null, direction);
            request.onsuccess = (event) => {
                const cursor = event.target.result;
                if (cursor && count > 0) {
                    const score = cursor.value;
                    // Process score
                    cursor.continue();
                }
            };
        }

        function loadLeaderboard() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['scores'], 'readonly');
                const store = transaction.objectStore('scores');
                const index = store.index('time');
                const direction = 'next'; // Changed from 'prev' - lower time is better
                const scores = [];

                const request = index.openCursor(null, direction);
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        scores.push(cursor.value);
                        cursor.continue();
                    } else {
                        resolve(scores.slice(0, 10));
                    }
                };
                request.onerror = () => reject(request.error);
            });
        }

        function showLeaderboardTable(scores, playerName, playerTime) {
            const leaderboard = document.getElementById('leaderboard');
            const table = document.getElementById('leaderboardTable');
            const playerEntry = document.getElementById('playerEntry');

            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += '<tr style="background: rgba(0,255,255,0.2);"><th style="padding: 8px; border: 1px solid #00ffff;">Rank</th><th style="padding: 8px; border: 1px solid #00ffff;">Name</th><th style="padding: 8px; border: 1px solid #00ffff;">Time</th><th style="padding: 8px; border: 1px solid #00ffff;">Date</th></tr>';

            scores.forEach((score, index) => {
                const isPlayer = score.nickname === playerName && score.time === playerTime;
                const rowStyle = isPlayer ? 'background: rgba(255,255,0,0.3);' : '';
                const date = new Date(score.date).toLocaleDateString();
                html += `<tr style="${rowStyle}"><td style="padding: 8px; border: 1px solid #00ffff;">${index + 1}</td><td style="padding: 8px; border: 1px solid #00ffff;">${score.nickname}</td><td style="padding: 8px; border: 1px solid #00ffff;">${formatTime(score.time)}</td><td style="padding: 8px; border: 1px solid #00ffff;">${date}</td></tr>`;
            });

            html += '</table>';
            table.innerHTML = html;

            // Show player's entry if not in top 10
            const playerInTop10 = scores.some(score => score.nickname === playerName && score.time === playerTime);
            if (!playerInTop10) {
                playerEntry.textContent = `Your Time: ${playerName} - ${formatTime(playerTime)}`;
            } else {
                playerEntry.textContent = '';
            }

            leaderboard.style.display = 'block';
        }

        function closeLeaderboard() {
            document.getElementById('leaderboard').style.display = 'none';
        }

        function promptNicknameAndSave(finalTime) {
            const nicknamePrompt = document.getElementById('nicknamePrompt');
            const input = document.getElementById('nicknameInput');

            // Display final time
            document.getElementById('finalTime').textContent = formatTime(finalTime);
            document.getElementById('victoryTime').textContent = formatTime(finalTime);

            nicknamePrompt.style.display = 'block';
            input.focus();

            // Store time globally for saving
            window.pendingTime = finalTime;
        }

        // Add pulse animation for hints
        const style = document.createElement('style');
        style.textContent = `
            @keyframes pulse {
                0% { transform: scale(1); }
                50% { transform: scale(1.2); background: rgba(255, 255, 0, 0.5); }
                100% { transform: scale(1); }
            }
        `;
        document.head.appendChild(style);

        // Initialize the game when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            console.log('DOM Content Loaded');

            // Attach event listeners to buttons
            const startBtn = document.getElementById('startGameBtn');
            const skipBtn = document.getElementById('skipBtn');

            if (startBtn) {
                console.log('Attaching click listener to START GAME button');
                startBtn.addEventListener('click', function (e) {
                    console.log('START GAME button clicked!');
                    e.preventDefault();
                    e.stopPropagation();
                    startGameFromPreview();
                });
            } else {
                console.error('START GAME button not found!');
            }

            if (skipBtn) {
                console.log('Attaching click listener to SKIP button');
                skipBtn.addEventListener('click', function (e) {
                    console.log('SKIP button clicked!');
                    e.preventDefault();
                    e.stopPropagation();
                    startGameFromPreview();
                });
            } else {
                console.error('SKIP button not found!');
            }

            // Check for lang parameter to determine if we should show preview
            const urlParams = new URLSearchParams(window.location.search);
            const lang = urlParams.get('lang');

            if (lang) {
                // Embedded in iframe - show preview
                console.log('Lang parameter detected:', lang);
                showMainMenu();
            } else {
                // Standalone - start game directly
                console.log('No lang parameter - starting game directly');
                newGame();
            }
        });
    </script>
</body>

</html>